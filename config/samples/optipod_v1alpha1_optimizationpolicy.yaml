# Example 1: Production workloads with Server-Side Apply (Recommended)
# 
# This is the recommended configuration for production environments, especially
# when using GitOps tools like ArgoCD. Server-Side Apply (SSA) enables field-level
# ownership, allowing OptipPod to manage resource requests/limits while other tools
# (like ArgoCD) manage other fields without conflicts.
#
# Use SSA when:
# - Using GitOps tools (ArgoCD, Flux, etc.)
# - Multiple tools manage the same workloads
# - You need clear field ownership tracking
# - Running Kubernetes 1.22+ (SSA is GA)
#
apiVersion: optipod.optipod.io/v1alpha1
kind: OptimizationPolicy
metadata:
  name: production-workloads-ssa
  namespace: default
spec:
  mode: Auto
  
  selector:
    namespaceSelector:
      matchLabels:
        environment: production
    workloadSelector:
      matchLabels:
        optimize: "true"
    namespaces:
      allow:
        - default
        - production
      deny:
        - kube-system
  
  metricsConfig:
    provider: prometheus
    rollingWindow: 24h
    percentile: P90
    safetyFactor: 1.2
  
  resourceBounds:
    cpu:
      min: "100m"
      max: "4000m"
    memory:
      min: "128Mi"
      max: "8Gi"
  
  updateStrategy:
    allowInPlaceResize: true
    allowRecreate: false
    updateRequestsOnly: true
    # Enable Server-Side Apply for field-level ownership (default: true)
    # This allows OptipPod to own only resource fields while other tools
    # manage different fields without conflicts
    useServerSideApply: true
  
  reconciliationInterval: 5m

---
# Example 2: Development workloads with Strategic Merge Patch
#
# This configuration uses the traditional Strategic Merge Patch method instead
# of Server-Side Apply. This may be useful in development environments or when
# SSA is not desired.
#
# Use Strategic Merge Patch when:
# - Only OptipPod manages the workloads (no other tools)
# - Running older Kubernetes versions (< 1.22)
# - Troubleshooting SSA-related issues
# - Simple single-tool management scenarios
#
apiVersion: optipod.optipod.io/v1alpha1
kind: OptimizationPolicy
metadata:
  name: dev-workloads-strategic-merge
  namespace: default
spec:
  mode: Auto
  
  selector:
    namespaceSelector:
      matchLabels:
        environment: development
    workloadSelector:
      matchLabels:
        optimize: "true"
  
  metricsConfig:
    provider: prometheus
    rollingWindow: 12h
    percentile: P95
    safetyFactor: 1.1
  
  resourceBounds:
    cpu:
      min: "50m"
      max: "2000m"
    memory:
      min: "64Mi"
      max: "4Gi"
  
  updateStrategy:
    allowInPlaceResize: true
    allowRecreate: true
    updateRequestsOnly: false
    # Disable Server-Side Apply to use Strategic Merge Patch
    useServerSideApply: false
  
  reconciliationInterval: 10m

---
# Example 3: ArgoCD-managed workloads with SSA (Best Practice)
#
# This configuration is optimized for workloads managed by ArgoCD. With SSA enabled,
# OptipPod and ArgoCD can coexist without sync conflicts. OptipPod owns resource
# requests/limits, while ArgoCD owns all other fields (image, replicas, env, etc.).
#
# Benefits:
# - No ArgoCD OutOfSync status for resource changes
# - ArgoCD syncs don't revert OptipPod's optimizations
# - Clear field ownership visible in managedFields
# - Full audit trail of who changed what
#
apiVersion: optipod.optipod.io/v1alpha1
kind: OptimizationPolicy
metadata:
  name: argocd-managed-apps
  namespace: default
spec:
  mode: Auto
  
  selector:
    workloadSelector:
      matchLabels:
        # Target workloads managed by ArgoCD
        argocd.argoproj.io/instance: my-app
  
  metricsConfig:
    provider: prometheus
    rollingWindow: 24h
    percentile: P90
    safetyFactor: 1.2
  
  resourceBounds:
    cpu:
      min: "100m"
      max: "4000m"
    memory:
      min: "128Mi"
      max: "8Gi"
  
  updateStrategy:
    allowInPlaceResize: true
    allowRecreate: false
    updateRequestsOnly: true
    # SSA is essential for ArgoCD compatibility
    useServerSideApply: true
  
  reconciliationInterval: 5m

---
# Example 4: Default behavior (SSA enabled implicitly)
#
# When useServerSideApply is not specified, it defaults to true.
# This is the recommended approach for most use cases.
#
apiVersion: optipod.optipod.io/v1alpha1
kind: OptimizationPolicy
metadata:
  name: default-behavior
  namespace: default
spec:
  mode: Auto
  
  selector:
    namespaceSelector:
      matchLabels:
        optimize: "true"
  
  metricsConfig:
    provider: prometheus
    rollingWindow: 24h
    percentile: P90
    safetyFactor: 1.2
  
  resourceBounds:
    cpu:
      min: "100m"
      max: "4000m"
    memory:
      min: "128Mi"
      max: "8Gi"
  
  updateStrategy:
    allowInPlaceResize: true
    allowRecreate: false
    updateRequestsOnly: true
    # useServerSideApply not specified - defaults to true
  
  reconciliationInterval: 5m

---
# Example 5: Workload Type Filtering - Include Only Deployments
#
# This configuration demonstrates how to target only specific workload types.
# Use this for gradual adoption, starting with low-risk workloads like Deployments
# before expanding to StatefulSets and DaemonSets.
#
# Use include filter when:
# - Starting with a specific workload type (e.g., Deployments only)
# - Testing optimization on a subset of workload types
# - Different teams manage different workload types
#
apiVersion: optipod.optipod.io/v1alpha1
kind: OptimizationPolicy
metadata:
  name: deployments-only
  namespace: default
spec:
  mode: Auto
  
  selector:
    namespaceSelector:
      matchLabels:
        environment: production
    # Only target Deployment workloads
    workloadTypes:
      include:
        - Deployment
  
  metricsConfig:
    provider: prometheus
    rollingWindow: 24h
    percentile: P90
    safetyFactor: 1.2
  
  resourceBounds:
    cpu:
      min: "100m"
      max: "4000m"
    memory:
      min: "128Mi"
      max: "8Gi"
  
  updateStrategy:
    allowInPlaceResize: true
    allowRecreate: false
    updateRequestsOnly: true
    useServerSideApply: true
  
  reconciliationInterval: 5m

---
# Example 6: Workload Type Filtering - Exclude StatefulSets
#
# This configuration demonstrates how to exclude specific workload types.
# Use this to prevent OptipPod from modifying stateful workloads that require
# careful resource management or have specific resource requirements.
#
# Use exclude filter when:
# - Protecting critical stateful workloads (databases, caches)
# - Certain workload types need manual resource management
# - Excluding workload types managed by other tools
#
apiVersion: optipod.optipod.io/v1alpha1
kind: OptimizationPolicy
metadata:
  name: exclude-statefulsets
  namespace: default
spec:
  mode: Auto
  
  selector:
    namespaceSelector:
      matchLabels:
        environment: production
    # Exclude StatefulSets from optimization
    workloadTypes:
      exclude:
        - StatefulSet
  
  metricsConfig:
    provider: prometheus
    rollingWindow: 24h
    percentile: P90
    safetyFactor: 1.2
  
  resourceBounds:
    cpu:
      min: "100m"
      max: "4000m"
    memory:
      min: "128Mi"
      max: "8Gi"
  
  updateStrategy:
    allowInPlaceResize: true
    allowRecreate: false
    updateRequestsOnly: true
    useServerSideApply: true
  
  reconciliationInterval: 5m

---
# Example 7: Workload Type Filtering - Multiple Types
#
# This configuration demonstrates including multiple workload types.
# This is useful when you want to optimize specific combinations of workload types
# while excluding others.
#
apiVersion: optipod.optipod.io/v1alpha1
kind: OptimizationPolicy
metadata:
  name: deployments-and-daemonsets
  namespace: default
spec:
  mode: Auto
  
  selector:
    namespaceSelector:
      matchLabels:
        environment: staging
    # Target both Deployments and DaemonSets, but not StatefulSets
    workloadTypes:
      include:
        - Deployment
        - DaemonSet
  
  metricsConfig:
    provider: prometheus
    rollingWindow: 12h
    percentile: P90
    safetyFactor: 1.15
  
  resourceBounds:
    cpu:
      min: "50m"
      max: "2000m"
    memory:
      min: "64Mi"
      max: "4Gi"
  
  updateStrategy:
    allowInPlaceResize: true
    allowRecreate: true
    updateRequestsOnly: true
    useServerSideApply: true
  
  reconciliationInterval: 10m

---
# Example 8: Workload Type Filtering - Exclude Precedence
#
# This configuration demonstrates that exclude takes precedence over include.
# Even though Deployment is in the include list, it's also in the exclude list,
# so Deployments will NOT be optimized. Only StatefulSets and DaemonSets will be
# targeted (since they're in include but not in exclude).
#
# This is useful for:
# - Temporarily disabling optimization for specific types
# - Complex filtering scenarios with multiple policies
#
apiVersion: optipod.optipod.io/v1alpha1
kind: OptimizationPolicy
metadata:
  name: exclude-precedence-example
  namespace: default
spec:
  mode: Auto
  
  selector:
    namespaceSelector:
      matchLabels:
        environment: development
    # Exclude takes precedence: Deployments will NOT be optimized
    workloadTypes:
      include:
        - Deployment
        - StatefulSet
        - DaemonSet
      exclude:
        - Deployment
  
  metricsConfig:
    provider: prometheus
    rollingWindow: 12h
    percentile: P90
    safetyFactor: 1.1
  
  resourceBounds:
    cpu:
      min: "50m"
      max: "2000m"
    memory:
      min: "64Mi"
      max: "4Gi"
  
  updateStrategy:
    allowInPlaceResize: true
    allowRecreate: true
    updateRequestsOnly: true
    useServerSideApply: true
  
  reconciliationInterval: 10m

---
# Example 9: Multiple Policies with Different Workload Types
#
# This demonstrates how to use multiple policies to apply different optimization
# strategies to different workload types. Each policy targets a specific workload
# type with appropriate settings.
#
# Policy for Deployments (aggressive optimization)
apiVersion: optipod.optipod.io/v1alpha1
kind: OptimizationPolicy
metadata:
  name: deployment-policy
  namespace: default
spec:
  mode: Auto
  weight: 100
  
  selector:
    namespaceSelector:
      matchLabels:
        environment: production
    workloadTypes:
      include:
        - Deployment
  
  metricsConfig:
    provider: prometheus
    rollingWindow: 24h
    percentile: P90
    safetyFactor: 1.1  # Lower safety factor for stateless workloads
  
  resourceBounds:
    cpu:
      min: "50m"
      max: "4000m"
    memory:
      min: "64Mi"
      max: "8Gi"
  
  updateStrategy:
    allowInPlaceResize: true
    allowRecreate: true  # Allow recreation for Deployments
    updateRequestsOnly: true
    useServerSideApply: true
  
  reconciliationInterval: 5m

---
# Policy for StatefulSets (conservative optimization)
apiVersion: optipod.optipod.io/v1alpha1
kind: OptimizationPolicy
metadata:
  name: statefulset-policy
  namespace: default
spec:
  mode: Recommend  # Only recommend, don't auto-apply for StatefulSets
  weight: 100
  
  selector:
    namespaceSelector:
      matchLabels:
        environment: production
    workloadTypes:
      include:
        - StatefulSet
  
  metricsConfig:
    provider: prometheus
    rollingWindow: 48h  # Longer window for stateful workloads
    percentile: P95     # Higher percentile for safety
    safetyFactor: 1.3   # Higher safety factor for stateful workloads
  
  resourceBounds:
    cpu:
      min: "100m"
      max: "8000m"
    memory:
      min: "256Mi"
      max: "16Gi"
  
  updateStrategy:
    allowInPlaceResize: true
    allowRecreate: false  # Never recreate StatefulSet pods
    updateRequestsOnly: true
    useServerSideApply: true
  
  reconciliationInterval: 15m
