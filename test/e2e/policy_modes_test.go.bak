//go:build e2e
// +build e2e

/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package e2e

import (
	"context"
	"fmt"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/optipod/optipod/api/v1alpha1"
	"github.com/optipod/optipod/test/e2e/helpers"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes/scheme"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/config"
)

var _ = Describe("Policy Mode Validation", Ordered, func() {
	var (
		k8sClient       client.Client
		policyHelper    *helpers.PolicyHelper
		workloadHelper  *helpers.WorkloadHelper
		cleanupHelper   *helpers.CleanupHelper
		testNamespace   string
		policyNamespace string
	)

	BeforeAll(func() {
		By("setting up test environment")

		// Initialize Kubernetes client
		cfg, err := config.GetConfig()
		Expect(err).NotTo(HaveOccurred())

		// Add OptipPod scheme
		s := runtime.NewScheme()
		Expect(scheme.AddToScheme(s)).To(Succeed())
		Expect(v1alpha1.AddToScheme(s)).To(Succeed())

		k8sClient, err = client.New(cfg, client.Options{Scheme: s})
		Expect(err).NotTo(HaveOccurred())

		// Set up namespaces
		testNamespace = "policy-mode-test"
		policyNamespace = "optipod-system"

		// Initialize helpers
		policyHelper = helpers.NewPolicyHelper(k8sClient, policyNamespace)
		workloadHelper = helpers.NewWorkloadHelper(k8sClient, testNamespace)
		cleanupHelper = helpers.NewCleanupHelper(k8sClient)

		// Create test namespace
		testNs := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNamespace,
				Labels: map[string]string{
					"environment": "test",
					"policy-test": "true",
				},
			},
		}
		err = k8sClient.Create(context.TODO(), testNs)
		Expect(err).NotTo(HaveOccurred())
		cleanupHelper.TrackNamespace(testNamespace)
	})

	AfterAll(func() {
		By("cleaning up test resources")
		err := cleanupHelper.CleanupAll()
		if err != nil {
			GinkgoWriter.Printf("Warning: cleanup failed: %v\n", err)
		}
	})

	Context("Auto Mode Policy Tests", func() {
		var (
			autoPolicy *v1alpha1.OptimizationPolicy
			policyName string
		)

		BeforeEach(func() {
			policyName = fmt.Sprintf("test-auto-policy-%d", time.Now().Unix())
		})

		AfterEach(func() {
			if autoPolicy != nil {
				err := policyHelper.DeletePolicy(policyName)
				if err != nil {
					GinkgoWriter.Printf("Warning: failed to delete policy %s: %v\n", policyName, err)
				}
			}
		})

		It("should create Auto mode policy successfully", func() {
			By("creating an Auto mode policy")
			config := helpers.PolicyConfig{
				Name: policyName,
				Mode: v1alpha1.ModeAuto,
				NamespaceSelector: map[string]string{
					"environment": "test",
				},
				WorkloadSelector: map[string]string{
					"auto-optimize": "true",
				},
				ResourceBounds: helpers.ResourceBounds{
					CPU: helpers.ResourceBound{
						Min: "100m",
						Max: "2000m",
					},
					Memory: helpers.ResourceBound{
						Min: "128Mi",
						Max: "2Gi",
					},
				},
				MetricsConfig: helpers.MetricsConfig{
					Provider:      "metrics-server",
					RollingWindow: "1h",
					Percentile:    "P90",
					SafetyFactor:  1.2,
				},
				UpdateStrategy: helpers.UpdateStrategy{
					AllowInPlaceResize: true,
					AllowRecreate:      false,
					UpdateRequestsOnly: true,
				},
				ReconciliationInterval: &metav1.Duration{Duration: 1 * time.Minute},
			}

			var err error
			autoPolicy, err = policyHelper.CreateOptimizationPolicy(config)
			Expect(err).NotTo(HaveOccurred())
			Expect(autoPolicy.Spec.Mode).To(Equal(v1alpha1.ModeAuto))

			cleanupHelper.TrackPolicy(policyName, policyNamespace)
		})

		It("should wait for Auto mode policy to be ready", func() {
			By("waiting for policy to reach Ready condition")
			err := policyHelper.WaitForPolicyReady(policyName, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())
		})

		It("should validate Auto mode policy behavior", func() {
			By("validating policy mode behavior")
			err := policyHelper.ValidatePolicyBehavior(policyName, v1alpha1.ModeAuto)
			Expect(err).NotTo(HaveOccurred())
		})

		It("should apply recommendations to Deployment workloads in Auto mode", func() {
			By("creating a Deployment with auto-optimize label")
			workloadConfig := helpers.WorkloadConfig{
				Name:      "auto-deployment-test",
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeDeployment,
				Labels: map[string]string{
					"auto-optimize": "true",
					"app":           "auto-deployment-test",
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "500m",
						Memory: "512Mi",
					},
					Limits: helpers.ResourceList{
						CPU:    "1000m",
						Memory: "1Gi",
					},
				},
				Replicas: 1,
				Image:    "nginx:1.25-alpine",
			}

			deployment, err := workloadHelper.CreateDeployment(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackDeployment(deployment.Name, deployment.Namespace)

			By("waiting for deployment to be ready")
			err = workloadHelper.WaitForWorkloadReady(deployment.Name, helpers.WorkloadTypeDeployment, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("waiting for policy to discover and process the workload")
			Eventually(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())
				g.Expect(policy.Status.WorkloadsDiscovered).To(BeNumerically(">=", 1))
			}, 3*time.Minute, 10*time.Second).Should(Succeed())

			By("verifying that recommendations are applied (lastApplied timestamp exists)")
			Eventually(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())

				// Find the workload in status
				var workloadFound bool
				for _, workload := range policy.Status.Workloads {
					if workload.Name == deployment.Name && workload.Namespace == deployment.Namespace {
						workloadFound = true
						g.Expect(workload.LastApplied).NotTo(BeNil(), "Auto mode should have lastApplied timestamp")
						break
					}
				}
				g.Expect(workloadFound).To(BeTrue(), "Workload should be found in policy status")
			}, 4*time.Minute, 15*time.Second).Should(Succeed())

			By("verifying workload annotations contain OptipPod management info")
			Eventually(func(g Gomega) {
				annotations, err := workloadHelper.GetWorkloadAnnotations(deployment.Name, helpers.WorkloadTypeDeployment)
				g.Expect(err).NotTo(HaveOccurred())
				g.Expect(annotations).To(HaveKey(ContainSubstring("optipod.io")), "Should have OptipPod annotations")
			}, 2*time.Minute, 10*time.Second).Should(Succeed())
		})

		It("should apply recommendations to StatefulSet workloads in Auto mode", func() {
			By("creating a StatefulSet with auto-optimize label")
			workloadConfig := helpers.WorkloadConfig{
				Name:      "auto-statefulset-test",
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeStatefulSet,
				Labels: map[string]string{
					"auto-optimize": "true",
					"app":           "auto-statefulset-test",
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "300m",
						Memory: "256Mi",
					},
					Limits: helpers.ResourceList{
						CPU:    "600m",
						Memory: "512Mi",
					},
				},
				Replicas: 1,
				Image:    "nginx:1.25-alpine",
			}

			statefulSet, err := workloadHelper.CreateStatefulSet(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackStatefulSet(statefulSet.Name, statefulSet.Namespace)

			By("waiting for statefulset to be ready")
			err = workloadHelper.WaitForWorkloadReady(statefulSet.Name, helpers.WorkloadTypeStatefulSet, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("waiting for policy to discover and process the workload")
			Eventually(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())

				// Find the workload in status
				var workloadFound bool
				for _, workload := range policy.Status.Workloads {
					if workload.Name == statefulSet.Name && workload.Namespace == statefulSet.Namespace {
						workloadFound = true
						break
					}
				}
				g.Expect(workloadFound).To(BeTrue(), "StatefulSet should be discovered by policy")
			}, 3*time.Minute, 10*time.Second).Should(Succeed())

			By("verifying that recommendations are applied")
			Eventually(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())

				// Find the workload in status
				for _, workload := range policy.Status.Workloads {
					if workload.Name == statefulSet.Name && workload.Namespace == statefulSet.Namespace {
						g.Expect(workload.LastApplied).NotTo(BeNil(), "Auto mode should apply recommendations to StatefulSet")
						return
					}
				}
				g.Fail("StatefulSet workload not found in policy status")
			}, 4*time.Minute, 15*time.Second).Should(Succeed())
		})

		It("should apply recommendations to DaemonSet workloads in Auto mode", func() {
			By("creating a DaemonSet with auto-optimize label")
			workloadConfig := helpers.WorkloadConfig{
				Name:      "auto-daemonset-test",
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeDaemonSet,
				Labels: map[string]string{
					"auto-optimize": "true",
					"app":           "auto-daemonset-test",
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "200m",
						Memory: "128Mi",
					},
					Limits: helpers.ResourceList{
						CPU:    "400m",
						Memory: "256Mi",
					},
				},
				Image: "nginx:1.25-alpine",
			}

			daemonSet, err := workloadHelper.CreateDaemonSet(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackDaemonSet(daemonSet.Name, daemonSet.Namespace)

			By("waiting for daemonset to be ready")
			err = workloadHelper.WaitForWorkloadReady(daemonSet.Name, helpers.WorkloadTypeDaemonSet, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("waiting for policy to discover and process the workload")
			Eventually(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())

				// Find the workload in status
				var workloadFound bool
				for _, workload := range policy.Status.Workloads {
					if workload.Name == daemonSet.Name && workload.Namespace == daemonSet.Namespace {
						workloadFound = true
						break
					}
				}
				g.Expect(workloadFound).To(BeTrue(), "DaemonSet should be discovered by policy")
			}, 3*time.Minute, 10*time.Second).Should(Succeed())

			By("verifying that recommendations are applied")
			Eventually(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())

				// Find the workload in status
				for _, workload := range policy.Status.Workloads {
					if workload.Name == daemonSet.Name && workload.Namespace == daemonSet.Namespace {
						g.Expect(workload.LastApplied).NotTo(BeNil(), "Auto mode should apply recommendations to DaemonSet")
						return
					}
				}
				g.Fail("DaemonSet workload not found in policy status")
			}, 4*time.Minute, 15*time.Second).Should(Succeed())
		})

		It("should validate lastApplied timestamps and resource modifications", func() {
			By("creating a test workload for timestamp validation")
			workloadConfig := helpers.WorkloadConfig{
				Name:      "timestamp-test",
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeDeployment,
				Labels: map[string]string{
					"auto-optimize": "true",
					"app":           "timestamp-test",
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "800m",
						Memory: "800Mi",
					},
				},
				Replicas: 1,
				Image:    "nginx:1.25-alpine",
			}

			deployment, err := workloadHelper.CreateDeployment(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackDeployment(deployment.Name, deployment.Namespace)

			By("waiting for deployment to be ready")
			err = workloadHelper.WaitForWorkloadReady(deployment.Name, helpers.WorkloadTypeDeployment, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("recording initial resource values")
			initialCPU := deployment.Spec.Template.Spec.Containers[0].Resources.Requests[corev1.ResourceCPU]
			initialMemory := deployment.Spec.Template.Spec.Containers[0].Resources.Requests[corev1.ResourceMemory]

			By("waiting for policy to process and apply recommendations")
			var lastAppliedTime *metav1.Time
			Eventually(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())

				// Find the workload in status
				for _, workload := range policy.Status.Workloads {
					if workload.Name == deployment.Name && workload.Namespace == deployment.Namespace {
						g.Expect(workload.LastApplied).NotTo(BeNil(), "Should have lastApplied timestamp")
						lastAppliedTime = workload.LastApplied
						return
					}
				}
				g.Fail("Workload not found in policy status")
			}, 4*time.Minute, 15*time.Second).Should(Succeed())

			By("verifying lastApplied timestamp is recent")
			Expect(lastAppliedTime).NotTo(BeNil())
			timeDiff := time.Since(lastAppliedTime.Time)
			Expect(timeDiff).To(BeNumerically("<", 10*time.Minute), "lastApplied should be recent")

			By("verifying resource modifications occurred")
			// Get updated deployment
			updatedDeployment, err := workloadHelper.GetWorkloadAnnotations(deployment.Name, helpers.WorkloadTypeDeployment)
			Expect(err).NotTo(HaveOccurred())

			// Should have OptipPod annotations indicating management
			Expect(updatedDeployment).To(HaveKey(ContainSubstring("optipod.io")), "Should have OptipPod management annotations")

			GinkgoWriter.Printf("Initial CPU: %s, Initial Memory: %s\n", initialCPU.String(), initialMemory.String())
			GinkgoWriter.Printf("LastApplied timestamp: %s\n", lastAppliedTime.String())
		})
	})

	Context("Recommend Mode Policy Tests", func() {
		var (
			recommendPolicy *v1alpha1.OptimizationPolicy
			policyName      string
		)

		BeforeEach(func() {
			policyName = fmt.Sprintf("test-recommend-policy-%d", time.Now().Unix())
		})

		AfterEach(func() {
			if recommendPolicy != nil {
				err := policyHelper.DeletePolicy(policyName)
				if err != nil {
					GinkgoWriter.Printf("Warning: failed to delete policy %s: %v\n", policyName, err)
				}
			}
		})

		It("should create Recommend mode policy successfully", func() {
			By("creating a Recommend mode policy")
			config := helpers.PolicyConfig{
				Name: policyName,
				Mode: v1alpha1.ModeRecommend,
				NamespaceSelector: map[string]string{
					"environment": "test",
				},
				WorkloadSelector: map[string]string{
					"recommend-optimize": "true",
				},
				ResourceBounds: helpers.ResourceBounds{
					CPU: helpers.ResourceBound{
						Min: "50m",
						Max: "1000m",
					},
					Memory: helpers.ResourceBound{
						Min: "64Mi",
						Max: "1Gi",
					},
				},
				MetricsConfig: helpers.MetricsConfig{
					Provider:      "metrics-server",
					RollingWindow: "30m",
					Percentile:    "P90",
					SafetyFactor:  1.1,
				},
				UpdateStrategy: helpers.UpdateStrategy{
					AllowInPlaceResize: true,
					AllowRecreate:      false,
					UpdateRequestsOnly: true,
				},
				ReconciliationInterval: &metav1.Duration{Duration: 2 * time.Minute},
			}

			var err error
			recommendPolicy, err = policyHelper.CreateOptimizationPolicy(config)
			Expect(err).NotTo(HaveOccurred())
			Expect(recommendPolicy.Spec.Mode).To(Equal(v1alpha1.ModeRecommend))

			cleanupHelper.TrackPolicy(policyName, policyNamespace)
		})

		It("should wait for Recommend mode policy to be ready", func() {
			By("waiting for policy to reach Ready condition")
			err := policyHelper.WaitForPolicyReady(policyName, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())
		})

		It("should validate Recommend mode policy behavior", func() {
			By("validating policy mode behavior")
			err := policyHelper.ValidatePolicyBehavior(policyName, v1alpha1.ModeRecommend)
			Expect(err).NotTo(HaveOccurred())
		})

		It("should generate recommendations without modifying Deployment workloads", func() {
			By("creating a Deployment with recommend-optimize label")
			workloadConfig := helpers.WorkloadConfig{
				Name:      "recommend-deployment-test",
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeDeployment,
				Labels: map[string]string{
					"recommend-optimize": "true",
					"app":                "recommend-deployment-test",
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "400m",
						Memory: "400Mi",
					},
					Limits: helpers.ResourceList{
						CPU:    "800m",
						Memory: "800Mi",
					},
				},
				Replicas: 1,
				Image:    "nginx:1.25-alpine",
			}

			deployment, err := workloadHelper.CreateDeployment(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackDeployment(deployment.Name, deployment.Namespace)

			By("waiting for deployment to be ready")
			err = workloadHelper.WaitForWorkloadReady(deployment.Name, helpers.WorkloadTypeDeployment, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("recording initial resource values")
			initialCPU := deployment.Spec.Template.Spec.Containers[0].Resources.Requests[corev1.ResourceCPU]
			initialMemory := deployment.Spec.Template.Spec.Containers[0].Resources.Requests[corev1.ResourceMemory]

			By("waiting for policy to discover and process the workload")
			Eventually(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())
				g.Expect(policy.Status.WorkloadsDiscovered).To(BeNumerically(">=", 1))
			}, 3*time.Minute, 10*time.Second).Should(Succeed())

			By("verifying that recommendations are generated but NOT applied")
			Eventually(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())

				// Find the workload in status
				var workloadFound bool
				for _, workload := range policy.Status.Workloads {
					if workload.Name == deployment.Name && workload.Namespace == deployment.Namespace {
						workloadFound = true
						g.Expect(workload.Recommendations).NotTo(BeEmpty(), "Recommend mode should generate recommendations")
						g.Expect(workload.LastApplied).To(BeNil(), "Recommend mode should NOT apply recommendations")
						break
					}
				}
				g.Expect(workloadFound).To(BeTrue(), "Workload should be found in policy status")
			}, 4*time.Minute, 15*time.Second).Should(Succeed())

			By("verifying workload resources remain unchanged")
			// Get current deployment to verify no changes
			currentDeployment := &appsv1.Deployment{}
			err = k8sClient.Get(context.TODO(), client.ObjectKey{
				Name:      deployment.Name,
				Namespace: deployment.Namespace,
			}, currentDeployment)
			Expect(err).NotTo(HaveOccurred())

			currentCPU := currentDeployment.Spec.Template.Spec.Containers[0].Resources.Requests[corev1.ResourceCPU]
			currentMemory := currentDeployment.Spec.Template.Spec.Containers[0].Resources.Requests[corev1.ResourceMemory]

			Expect(currentCPU.Equal(initialCPU)).To(BeTrue(), "CPU requests should remain unchanged in Recommend mode")
			Expect(currentMemory.Equal(initialMemory)).To(BeTrue(), "Memory requests should remain unchanged in Recommend mode")

			GinkgoWriter.Printf("Initial CPU: %s, Current CPU: %s\n", initialCPU.String(), currentCPU.String())
			GinkgoWriter.Printf("Initial Memory: %s, Current Memory: %s\n", initialMemory.String(), currentMemory.String())
		})

		It("should generate recommendations for StatefulSet workloads without modifications", func() {
			By("creating a StatefulSet with recommend-optimize label")
			workloadConfig := helpers.WorkloadConfig{
				Name:      "recommend-statefulset-test",
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeStatefulSet,
				Labels: map[string]string{
					"recommend-optimize": "true",
					"app":                "recommend-statefulset-test",
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "250m",
						Memory: "200Mi",
					},
					Limits: helpers.ResourceList{
						CPU:    "500m",
						Memory: "400Mi",
					},
				},
				Replicas: 1,
				Image:    "nginx:1.25-alpine",
			}

			statefulSet, err := workloadHelper.CreateStatefulSet(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackStatefulSet(statefulSet.Name, statefulSet.Namespace)

			By("waiting for statefulset to be ready")
			err = workloadHelper.WaitForWorkloadReady(statefulSet.Name, helpers.WorkloadTypeStatefulSet, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("waiting for policy to discover and process the workload")
			Eventually(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())

				// Find the workload in status
				var workloadFound bool
				for _, workload := range policy.Status.Workloads {
					if workload.Name == statefulSet.Name && workload.Namespace == statefulSet.Namespace {
						workloadFound = true
						break
					}
				}
				g.Expect(workloadFound).To(BeTrue(), "StatefulSet should be discovered by policy")
			}, 3*time.Minute, 10*time.Second).Should(Succeed())

			By("verifying that recommendations are generated but NOT applied")
			Eventually(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())

				// Find the workload in status
				for _, workload := range policy.Status.Workloads {
					if workload.Name == statefulSet.Name && workload.Namespace == statefulSet.Namespace {
						g.Expect(workload.Recommendations).NotTo(BeEmpty(), "Should generate recommendations for StatefulSet")
						g.Expect(workload.LastApplied).To(BeNil(), "Should NOT apply recommendations to StatefulSet in Recommend mode")
						return
					}
				}
				g.Fail("StatefulSet workload not found in policy status")
			}, 4*time.Minute, 15*time.Second).Should(Succeed())
		})

		It("should validate recommendation format and content", func() {
			By("creating a test workload for recommendation validation")
			workloadConfig := helpers.WorkloadConfig{
				Name:      "recommendation-format-test",
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeDeployment,
				Labels: map[string]string{
					"recommend-optimize": "true",
					"app":                "recommendation-format-test",
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "600m",
						Memory: "600Mi",
					},
				},
				Replicas: 1,
				Image:    "nginx:1.25-alpine",
			}

			deployment, err := workloadHelper.CreateDeployment(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackDeployment(deployment.Name, deployment.Namespace)

			By("waiting for deployment to be ready")
			err = workloadHelper.WaitForWorkloadReady(deployment.Name, helpers.WorkloadTypeDeployment, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("waiting for recommendations to be generated")
			var recommendations []v1alpha1.ContainerRecommendation
			Eventually(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())

				// Find the workload in status
				for _, workload := range policy.Status.Workloads {
					if workload.Name == deployment.Name && workload.Namespace == deployment.Namespace {
						g.Expect(workload.Recommendations).NotTo(BeEmpty(), "Should have recommendations")
						recommendations = workload.Recommendations
						return
					}
				}
				g.Fail("Workload not found in policy status")
			}, 4*time.Minute, 15*time.Second).Should(Succeed())

			By("validating recommendation format and content")
			Expect(recommendations).NotTo(BeEmpty(), "Should have at least one recommendation")

			for _, rec := range recommendations {
				Expect(rec.Container).NotTo(BeEmpty(), "Container name should be specified")

				// At least one of CPU or Memory should be recommended
				Expect(rec.CPU != nil || rec.Memory != nil).To(BeTrue(), "Should recommend at least CPU or Memory")

				// If CPU is recommended, it should be within bounds
				if rec.CPU != nil {
					cpuQuantity := *rec.CPU
					minCPU := resource.MustParse("50m")
					maxCPU := resource.MustParse("1000m")

					Expect(cpuQuantity.Cmp(minCPU)).To(BeNumerically(">=", 0), "CPU recommendation should be >= min bound")
					Expect(cpuQuantity.Cmp(maxCPU)).To(BeNumerically("<=", 0), "CPU recommendation should be <= max bound")
				}

				// If Memory is recommended, it should be within bounds
				if rec.Memory != nil {
					memoryQuantity := *rec.Memory
					minMemory := resource.MustParse("64Mi")
					maxMemory := resource.MustParse("1Gi")

					Expect(memoryQuantity.Cmp(minMemory)).To(BeNumerically(">=", 0), "Memory recommendation should be >= min bound")
					Expect(memoryQuantity.Cmp(maxMemory)).To(BeNumerically("<=", 0), "Memory recommendation should be <= max bound")
				}

				GinkgoWriter.Printf("Recommendation for container %s: CPU=%v, Memory=%v\n",
					rec.Container, rec.CPU, rec.Memory)
			}
		})

		It("should generate recommendations in annotations without workload updates", func() {
			By("creating a workload for annotation testing")
			workloadConfig := helpers.WorkloadConfig{
				Name:      "annotation-test",
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeDeployment,
				Labels: map[string]string{
					"recommend-optimize": "true",
					"app":                "annotation-test",
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "700m",
						Memory: "700Mi",
					},
				},
				Replicas: 1,
				Image:    "nginx:1.25-alpine",
			}

			deployment, err := workloadHelper.CreateDeployment(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackDeployment(deployment.Name, deployment.Namespace)

			By("waiting for deployment to be ready")
			err = workloadHelper.WaitForWorkloadReady(deployment.Name, helpers.WorkloadTypeDeployment, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("waiting for OptipPod annotations to be added")
			Eventually(func(g Gomega) {
				annotations, err := workloadHelper.GetWorkloadAnnotations(deployment.Name, helpers.WorkloadTypeDeployment)
				g.Expect(err).NotTo(HaveOccurred())
				g.Expect(annotations).To(HaveKey(ContainSubstring("optipod.io")), "Should have OptipPod annotations")
			}, 4*time.Minute, 15*time.Second).Should(Succeed())

			By("verifying annotation content contains recommendation information")
			annotations, err := workloadHelper.GetWorkloadAnnotations(deployment.Name, helpers.WorkloadTypeDeployment)
			Expect(err).NotTo(HaveOccurred())

			// Should have management annotations but no lastApplied
			var hasRecommendationAnnotation bool
			var hasLastAppliedAnnotation bool

			for key := range annotations {
				if key == v1alpha1.AnnotationLastRecommendation {
					hasRecommendationAnnotation = true
				}
				if key == v1alpha1.AnnotationLastApplied {
					hasLastAppliedAnnotation = true
				}
			}

			Expect(hasRecommendationAnnotation).To(BeTrue(), "Should have last recommendation annotation")
			Expect(hasLastAppliedAnnotation).To(BeFalse(), "Should NOT have last applied annotation in Recommend mode")

			GinkgoWriter.Printf("OptipPod annotations: %v\n", annotations)
		})
	})

	Context("Disabled Mode Policy Tests", func() {
		var (
			disabledPolicy *v1alpha1.OptimizationPolicy
			policyName     string
		)

		BeforeEach(func() {
			policyName = fmt.Sprintf("test-disabled-policy-%d", time.Now().Unix())
		})

		AfterEach(func() {
			if disabledPolicy != nil {
				err := policyHelper.DeletePolicy(policyName)
				if err != nil {
					GinkgoWriter.Printf("Warning: failed to delete policy %s: %v\n", policyName, err)
				}
			}
		})

		It("should create Disabled mode policy successfully", func() {
			By("creating a Disabled mode policy")
			config := helpers.PolicyConfig{
				Name: policyName,
				Mode: v1alpha1.ModeDisabled,
				NamespaceSelector: map[string]string{
					"environment": "test",
				},
				WorkloadSelector: map[string]string{
					"disabled-optimize": "true",
				},
				ResourceBounds: helpers.ResourceBounds{
					CPU: helpers.ResourceBound{
						Min: "100m",
						Max: "500m",
					},
					Memory: helpers.ResourceBound{
						Min: "128Mi",
						Max: "512Mi",
					},
				},
				MetricsConfig: helpers.MetricsConfig{
					Provider:      "metrics-server",
					RollingWindow: "1h",
					Percentile:    "P90",
					SafetyFactor:  1.0,
				},
				UpdateStrategy: helpers.UpdateStrategy{
					AllowInPlaceResize: false,
					AllowRecreate:      false,
					UpdateRequestsOnly: true,
				},
				ReconciliationInterval: &metav1.Duration{Duration: 5 * time.Minute},
			}

			var err error
			disabledPolicy, err = policyHelper.CreateOptimizationPolicy(config)
			Expect(err).NotTo(HaveOccurred())
			Expect(disabledPolicy.Spec.Mode).To(Equal(v1alpha1.ModeDisabled))

			cleanupHelper.TrackPolicy(policyName, policyNamespace)
		})

		It("should wait for Disabled mode policy to be ready", func() {
			By("waiting for policy to reach Ready condition")
			err := policyHelper.WaitForPolicyReady(policyName, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())
		})

		It("should validate Disabled mode policy behavior", func() {
			By("validating policy mode behavior")
			err := policyHelper.ValidatePolicyBehavior(policyName, v1alpha1.ModeDisabled)
			Expect(err).NotTo(HaveOccurred())
		})

		It("should NOT process Deployment workloads in Disabled mode", func() {
			By("creating a Deployment with disabled-optimize label")
			workloadConfig := helpers.WorkloadConfig{
				Name:      "disabled-deployment-test",
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeDeployment,
				Labels: map[string]string{
					"disabled-optimize": "true",
					"app":               "disabled-deployment-test",
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "300m",
						Memory: "300Mi",
					},
					Limits: helpers.ResourceList{
						CPU:    "600m",
						Memory: "600Mi",
					},
				},
				Replicas: 1,
				Image:    "nginx:1.25-alpine",
			}

			deployment, err := workloadHelper.CreateDeployment(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackDeployment(deployment.Name, deployment.Namespace)

			By("waiting for deployment to be ready")
			err = workloadHelper.WaitForWorkloadReady(deployment.Name, helpers.WorkloadTypeDeployment, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("recording initial resource values")
			initialCPU := deployment.Spec.Template.Spec.Containers[0].Resources.Requests[corev1.ResourceCPU]
			initialMemory := deployment.Spec.Template.Spec.Containers[0].Resources.Requests[corev1.ResourceMemory]

			By("waiting and verifying workload is NOT processed by disabled policy")
			Consistently(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())

				// In Disabled mode, workloads should not be processed
				g.Expect(policy.Status.WorkloadsDiscovered).To(Equal(0), "Disabled policy should not discover workloads")
				g.Expect(policy.Status.WorkloadsProcessed).To(Equal(0), "Disabled policy should not process workloads")
				g.Expect(len(policy.Status.Workloads)).To(Equal(0), "Disabled policy should have no workloads in status")
			}, 2*time.Minute, 15*time.Second).Should(Succeed())

			By("verifying workload resources remain completely unchanged")
			// Get current deployment to verify no changes
			currentDeployment := &appsv1.Deployment{}
			err = k8sClient.Get(context.TODO(), client.ObjectKey{
				Name:      deployment.Name,
				Namespace: deployment.Namespace,
			}, currentDeployment)
			Expect(err).NotTo(HaveOccurred())

			currentCPU := currentDeployment.Spec.Template.Spec.Containers[0].Resources.Requests[corev1.ResourceCPU]
			currentMemory := currentDeployment.Spec.Template.Spec.Containers[0].Resources.Requests[corev1.ResourceMemory]

			Expect(currentCPU.Equal(initialCPU)).To(BeTrue(), "CPU requests should remain unchanged in Disabled mode")
			Expect(currentMemory.Equal(initialMemory)).To(BeTrue(), "Memory requests should remain unchanged in Disabled mode")

			By("verifying no OptipPod annotations are added")
			annotations, err := workloadHelper.GetWorkloadAnnotations(deployment.Name, helpers.WorkloadTypeDeployment)
			Expect(err).NotTo(HaveOccurred())

			// Should have no OptipPod annotations
			var hasOptipPodAnnotations bool
			for key := range annotations {
				if len(key) >= 10 && key[:10] == "optipod.io" {
					hasOptipPodAnnotations = true
					break
				}
			}
			Expect(hasOptipPodAnnotations).To(BeFalse(), "Disabled policy should not add OptipPod annotations")

			GinkgoWriter.Printf("Verified no processing for deployment in Disabled mode\n")
		})

		It("should NOT process StatefulSet workloads in Disabled mode", func() {
			By("creating a StatefulSet with disabled-optimize label")
			workloadConfig := helpers.WorkloadConfig{
				Name:      "disabled-statefulset-test",
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeStatefulSet,
				Labels: map[string]string{
					"disabled-optimize": "true",
					"app":               "disabled-statefulset-test",
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "200m",
						Memory: "200Mi",
					},
					Limits: helpers.ResourceList{
						CPU:    "400m",
						Memory: "400Mi",
					},
				},
				Replicas: 1,
				Image:    "nginx:1.25-alpine",
			}

			statefulSet, err := workloadHelper.CreateStatefulSet(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackStatefulSet(statefulSet.Name, statefulSet.Namespace)

			By("waiting for statefulset to be ready")
			err = workloadHelper.WaitForWorkloadReady(statefulSet.Name, helpers.WorkloadTypeStatefulSet, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("waiting and verifying StatefulSet is NOT processed by disabled policy")
			Consistently(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())

				// Should not find this workload in policy status
				for _, workload := range policy.Status.Workloads {
					g.Expect(workload.Name).NotTo(Equal(statefulSet.Name), "StatefulSet should not be processed in Disabled mode")
				}
			}, 2*time.Minute, 15*time.Second).Should(Succeed())

			By("verifying no OptipPod annotations are added to StatefulSet")
			annotations, err := workloadHelper.GetWorkloadAnnotations(statefulSet.Name, helpers.WorkloadTypeStatefulSet)
			Expect(err).NotTo(HaveOccurred())

			// Should have no OptipPod annotations
			var hasOptipPodAnnotations bool
			for key := range annotations {
				if len(key) >= 10 && key[:10] == "optipod.io" {
					hasOptipPodAnnotations = true
					break
				}
			}
			Expect(hasOptipPodAnnotations).To(BeFalse(), "Disabled policy should not add OptipPod annotations to StatefulSet")
		})

		It("should NOT process DaemonSet workloads in Disabled mode", func() {
			By("creating a DaemonSet with disabled-optimize label")
			workloadConfig := helpers.WorkloadConfig{
				Name:      "disabled-daemonset-test",
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeDaemonSet,
				Labels: map[string]string{
					"disabled-optimize": "true",
					"app":               "disabled-daemonset-test",
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "150m",
						Memory: "150Mi",
					},
					Limits: helpers.ResourceList{
						CPU:    "300m",
						Memory: "300Mi",
					},
				},
				Image: "nginx:1.25-alpine",
			}

			daemonSet, err := workloadHelper.CreateDaemonSet(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackDaemonSet(daemonSet.Name, daemonSet.Namespace)

			By("waiting for daemonset to be ready")
			err = workloadHelper.WaitForWorkloadReady(daemonSet.Name, helpers.WorkloadTypeDaemonSet, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("waiting and verifying DaemonSet is NOT processed by disabled policy")
			Consistently(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())

				// Should not find this workload in policy status
				for _, workload := range policy.Status.Workloads {
					g.Expect(workload.Name).NotTo(Equal(daemonSet.Name), "DaemonSet should not be processed in Disabled mode")
				}
			}, 2*time.Minute, 15*time.Second).Should(Succeed())

			By("verifying no OptipPod annotations are added to DaemonSet")
			annotations, err := workloadHelper.GetWorkloadAnnotations(daemonSet.Name, helpers.WorkloadTypeDaemonSet)
			Expect(err).NotTo(HaveOccurred())

			// Should have no OptipPod annotations
			var hasOptipPodAnnotations bool
			for key := range annotations {
				if len(key) >= 10 && key[:10] == "optipod.io" {
					hasOptipPodAnnotations = true
					break
				}
			}
			Expect(hasOptipPodAnnotations).To(BeFalse(), "Disabled policy should not add OptipPod annotations to DaemonSet")
		})

		It("should validate that controller logs reflect disabled state", func() {
			By("creating a workload that would normally be processed")
			workloadConfig := helpers.WorkloadConfig{
				Name:      "disabled-log-test",
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeDeployment,
				Labels: map[string]string{
					"disabled-optimize": "true",
					"app":               "disabled-log-test",
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "400m",
						Memory: "400Mi",
					},
				},
				Replicas: 1,
				Image:    "nginx:1.25-alpine",
			}

			deployment, err := workloadHelper.CreateDeployment(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackDeployment(deployment.Name, deployment.Namespace)

			By("waiting for deployment to be ready")
			err = workloadHelper.WaitForWorkloadReady(deployment.Name, helpers.WorkloadTypeDeployment, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("verifying policy remains in disabled state with no workload processing")
			Consistently(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())

				// Policy should remain disabled
				g.Expect(policy.Spec.Mode).To(Equal(v1alpha1.ModeDisabled))
				g.Expect(len(policy.Status.Workloads)).To(Equal(0), "No workloads should be processed")

				// Check that policy is ready but not processing
				var isReady bool
				for _, condition := range policy.Status.Conditions {
					if condition.Type == "Ready" && condition.Status == metav1.ConditionTrue {
						isReady = true
						break
					}
				}
				g.Expect(isReady).To(BeTrue(), "Policy should be ready even in Disabled mode")
			}, 2*time.Minute, 15*time.Second).Should(Succeed())

			GinkgoWriter.Printf("Verified policy %s remains disabled and processes no workloads\n", policyName)
		})

		It("should validate no annotations or modifications occur in Disabled mode", func() {
			By("creating multiple workloads with disabled-optimize label")
			workloadConfigs := []helpers.WorkloadConfig{
				{
					Name:      "disabled-multi-test-1",
					Namespace: testNamespace,
					Type:      helpers.WorkloadTypeDeployment,
					Labels: map[string]string{
						"disabled-optimize": "true",
						"app":               "disabled-multi-test-1",
					},
					Resources: helpers.ResourceRequirements{
						Requests: helpers.ResourceList{
							CPU:    "250m",
							Memory: "250Mi",
						},
					},
					Replicas: 1,
					Image:    "nginx:1.25-alpine",
				},
				{
					Name:      "disabled-multi-test-2",
					Namespace: testNamespace,
					Type:      helpers.WorkloadTypeDeployment,
					Labels: map[string]string{
						"disabled-optimize": "true",
						"app":               "disabled-multi-test-2",
					},
					Resources: helpers.ResourceRequirements{
						Requests: helpers.ResourceList{
							CPU:    "350m",
							Memory: "350Mi",
						},
					},
					Replicas: 1,
					Image:    "nginx:1.25-alpine",
				},
			}

			var deployments []*appsv1.Deployment
			for _, config := range workloadConfigs {
				deployment, err := workloadHelper.CreateDeployment(config)
				Expect(err).NotTo(HaveOccurred())
				cleanupHelper.TrackDeployment(deployment.Name, deployment.Namespace)
				deployments = append(deployments, deployment)

				// Wait for each deployment to be ready
				err = workloadHelper.WaitForWorkloadReady(deployment.Name, helpers.WorkloadTypeDeployment, 2*time.Minute)
				Expect(err).NotTo(HaveOccurred())
			}

			By("verifying none of the workloads are processed or modified")
			Consistently(func(g Gomega) {
				policy, err := policyHelper.GetPolicy(policyName)
				g.Expect(err).NotTo(HaveOccurred())

				// No workloads should be in policy status
				g.Expect(len(policy.Status.Workloads)).To(Equal(0), "No workloads should be processed in Disabled mode")
				g.Expect(policy.Status.WorkloadsDiscovered).To(Equal(0), "No workloads should be discovered")
				g.Expect(policy.Status.WorkloadsProcessed).To(Equal(0), "No workloads should be processed")

				// Verify no annotations on any workload
				for _, deployment := range deployments {
					annotations, err := workloadHelper.GetWorkloadAnnotations(deployment.Name, helpers.WorkloadTypeDeployment)
					g.Expect(err).NotTo(HaveOccurred())

					var hasOptipPodAnnotations bool
					for key := range annotations {
						if len(key) >= 10 && key[:10] == "optipod.io" {
							hasOptipPodAnnotations = true
							break
						}
					}
					g.Expect(hasOptipPodAnnotations).To(BeFalse(),
						fmt.Sprintf("Deployment %s should not have OptipPod annotations in Disabled mode", deployment.Name))
				}
			}, 2*time.Minute, 15*time.Second).Should(Succeed())

			GinkgoWriter.Printf("Verified %d workloads remain unprocessed in Disabled mode\n", len(deployments))
		})
	})

	Context("Policy Mode Unit Tests", func() {
		It("should validate policy creation helpers", func() {
			By("testing PolicyConfig validation")
			config := helpers.PolicyConfig{
				Name: "unit-test-policy",
				Mode: v1alpha1.ModeAuto,
				NamespaceSelector: map[string]string{
					"environment": "test",
				},
				WorkloadSelector: map[string]string{
					"optimize": "true",
				},
				ResourceBounds: helpers.ResourceBounds{
					CPU: helpers.ResourceBound{
						Min: "100m",
						Max: "1000m",
					},
					Memory: helpers.ResourceBound{
						Min: "128Mi",
						Max: "1Gi",
					},
				},
				MetricsConfig: helpers.MetricsConfig{
					Provider:      "metrics-server",
					RollingWindow: "1h",
					Percentile:    "P90",
					SafetyFactor:  1.2,
				},
				UpdateStrategy: helpers.UpdateStrategy{
					AllowInPlaceResize: true,
					AllowRecreate:      false,
					UpdateRequestsOnly: true,
				},
			}

			// Test policy creation
			policy, err := policyHelper.CreateOptimizationPolicy(config)
			Expect(err).NotTo(HaveOccurred())
			Expect(policy).NotTo(BeNil())
			Expect(policy.Spec.Mode).To(Equal(v1alpha1.ModeAuto))
			Expect(policy.Spec.Selector.NamespaceSelector.MatchLabels).To(Equal(config.NamespaceSelector))
			Expect(policy.Spec.Selector.WorkloadSelector.MatchLabels).To(Equal(config.WorkloadSelector))

			cleanupHelper.TrackPolicy(policy.Name, policy.Namespace)
		})

		It("should validate mode validation logic", func() {
			By("testing Auto mode validation")
			autoConfig := helpers.PolicyConfig{
				Name: "auto-validation-test",
				Mode: v1alpha1.ModeAuto,
				NamespaceSelector: map[string]string{
					"test": "auto",
				},
				WorkloadSelector: map[string]string{
					"optimize": "true",
				},
				ResourceBounds: helpers.ResourceBounds{
					CPU: helpers.ResourceBound{
						Min: "50m",
						Max: "500m",
					},
					Memory: helpers.ResourceBound{
						Min: "64Mi",
						Max: "512Mi",
					},
				},
				MetricsConfig: helpers.MetricsConfig{
					Provider:      "metrics-server",
					RollingWindow: "30m",
					Percentile:    "P90",
					SafetyFactor:  1.1,
				},
				UpdateStrategy: helpers.UpdateStrategy{
					AllowInPlaceResize: true,
					AllowRecreate:      false,
					UpdateRequestsOnly: true,
				},
			}

			autoPolicy, err := policyHelper.CreateOptimizationPolicy(autoConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackPolicy(autoPolicy.Name, autoPolicy.Namespace)

			// Wait for policy to be ready
			err = policyHelper.WaitForPolicyReady(autoPolicy.Name, 1*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			// Validate mode behavior
			err = policyHelper.ValidatePolicyBehavior(autoPolicy.Name, v1alpha1.ModeAuto)
			Expect(err).NotTo(HaveOccurred())

			By("testing Recommend mode validation")
			recommendConfig := autoConfig
			recommendConfig.Name = "recommend-validation-test"
			recommendConfig.Mode = v1alpha1.ModeRecommend
			recommendConfig.WorkloadSelector = map[string]string{
				"recommend": "true",
			}

			recommendPolicy, err := policyHelper.CreateOptimizationPolicy(recommendConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackPolicy(recommendPolicy.Name, recommendPolicy.Namespace)

			// Wait for policy to be ready
			err = policyHelper.WaitForPolicyReady(recommendPolicy.Name, 1*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			// Validate mode behavior
			err = policyHelper.ValidatePolicyBehavior(recommendPolicy.Name, v1alpha1.ModeRecommend)
			Expect(err).NotTo(HaveOccurred())

			By("testing Disabled mode validation")
			disabledConfig := autoConfig
			disabledConfig.Name = "disabled-validation-test"
			disabledConfig.Mode = v1alpha1.ModeDisabled
			disabledConfig.WorkloadSelector = map[string]string{
				"disabled": "true",
			}

			disabledPolicy, err := policyHelper.CreateOptimizationPolicy(disabledConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackPolicy(disabledPolicy.Name, disabledPolicy.Namespace)

			// Wait for policy to be ready
			err = policyHelper.WaitForPolicyReady(disabledPolicy.Name, 1*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			// Validate mode behavior
			err = policyHelper.ValidatePolicyBehavior(disabledPolicy.Name, v1alpha1.ModeDisabled)
			Expect(err).NotTo(HaveOccurred())
		})

		It("should validate annotation parsing logic", func() {
			By("testing OptipPod annotation constants")
			// Verify annotation constants are properly defined
			Expect(v1alpha1.AnnotationManaged).To(Equal("optipod.io/managed"))
			Expect(v1alpha1.AnnotationPolicy).To(Equal("optipod.io/policy"))
			Expect(v1alpha1.AnnotationLastRecommendation).To(Equal("optipod.io/last-recommendation"))
			Expect(v1alpha1.AnnotationLastApplied).To(Equal("optipod.io/last-applied"))
			Expect(v1alpha1.AnnotationRecommendationPrefix).To(Equal("optipod.io/recommendation"))

			By("testing annotation key generation")
			containerName := "test-container"
			expectedCPUKey := fmt.Sprintf("%s.%s.cpu", v1alpha1.AnnotationRecommendationPrefix, containerName)
			expectedMemoryKey := fmt.Sprintf("%s.%s.memory", v1alpha1.AnnotationRecommendationPrefix, containerName)

			Expect(expectedCPUKey).To(Equal("optipod.io/recommendation.test-container.cpu"))
			Expect(expectedMemoryKey).To(Equal("optipod.io/recommendation.test-container.memory"))

			By("testing annotation filtering logic")
			testAnnotations := map[string]string{
				"app":                                  "test-app",
				"version":                              "1.0.0",
				"optipod.io/managed":                   "true",
				"optipod.io/policy":                    "test-policy",
				"optipod.io/last-recommendation":       "2023-01-01T00:00:00Z",
				"optipod.io/recommendation.app.cpu":    "100m",
				"optipod.io/recommendation.app.memory": "128Mi",
				"other.io/annotation":                  "value",
			}

			// Filter OptipPod annotations
			optipodAnnotations := make(map[string]string)
			for key, value := range testAnnotations {
				if len(key) >= 10 && key[:10] == "optipod.io" {
					optipodAnnotations[key] = value
				}
			}

			// Should have 4 OptipPod annotations
			Expect(len(optipodAnnotations)).To(Equal(4))
			Expect(optipodAnnotations).To(HaveKey("optipod.io/managed"))
			Expect(optipodAnnotations).To(HaveKey("optipod.io/policy"))
			Expect(optipodAnnotations).To(HaveKey("optipod.io/last-recommendation"))
			Expect(optipodAnnotations).To(HaveKey("optipod.io/recommendation.app.cpu"))
			Expect(optipodAnnotations).NotTo(HaveKey("app"))
			Expect(optipodAnnotations).NotTo(HaveKey("other.io/annotation"))
		})

		It("should validate resource bounds parsing", func() {
			By("testing resource quantity parsing and comparison")
			// Test CPU quantities
			cpu100m := resource.MustParse("100m")
			cpu200m := resource.MustParse("200m")
			cpu1 := resource.MustParse("1")
			cpu1000m := resource.MustParse("1000m")

			// 1 CPU = 1000m
			Expect(cpu1.Equal(cpu1000m)).To(BeTrue())
			Expect(cpu100m.Cmp(cpu200m)).To(Equal(-1)) // 100m < 200m
			Expect(cpu200m.Cmp(cpu100m)).To(Equal(1))  // 200m > 100m

			// Test Memory quantities
			mem128Mi := resource.MustParse("128Mi")
			mem256Mi := resource.MustParse("256Mi")
			mem1Gi := resource.MustParse("1Gi")
			mem1024Mi := resource.MustParse("1024Mi")

			// 1Gi = 1024Mi
			Expect(mem1Gi.Equal(mem1024Mi)).To(BeTrue())
			Expect(mem128Mi.Cmp(mem256Mi)).To(Equal(-1)) // 128Mi < 256Mi
			Expect(mem256Mi.Cmp(mem128Mi)).To(Equal(1))  // 256Mi > 128Mi

			By("testing bounds validation logic")
			// Test valid bounds
			validCPUBounds := helpers.ResourceBound{
				Min: "100m",
				Max: "1000m",
			}
			minCPU := resource.MustParse(validCPUBounds.Min)
			maxCPU := resource.MustParse(validCPUBounds.Max)
			Expect(minCPU.Cmp(maxCPU)).To(Equal(-1)) // min < max is valid

			// Test recommendation within bounds
			recommendedCPU := resource.MustParse("500m")
			Expect(recommendedCPU.Cmp(minCPU)).To(BeNumerically(">=", 0)) // recommended >= min
			Expect(recommendedCPU.Cmp(maxCPU)).To(BeNumerically("<=", 0)) // recommended <= max

			// Test clamping logic
			belowMinCPU := resource.MustParse("50m")
			aboveMaxCPU := resource.MustParse("2000m")

			// Simulate clamping
			clampedMin := belowMinCPU
			if belowMinCPU.Cmp(minCPU) < 0 {
				clampedMin = minCPU
			}
			Expect(clampedMin.Equal(minCPU)).To(BeTrue())

			clampedMax := aboveMaxCPU
			if aboveMaxCPU.Cmp(maxCPU) > 0 {
				clampedMax = maxCPU
			}
			Expect(clampedMax.Equal(maxCPU)).To(BeTrue())
		})

		It("should validate policy mode enum values", func() {
			By("testing PolicyMode enum constants")
			Expect(string(v1alpha1.ModeAuto)).To(Equal("Auto"))
			Expect(string(v1alpha1.ModeRecommend)).To(Equal("Recommend"))
			Expect(string(v1alpha1.ModeDisabled)).To(Equal("Disabled"))

			By("testing mode validation in policy creation")
			// Test valid modes
			validModes := []v1alpha1.PolicyMode{
				v1alpha1.ModeAuto,
				v1alpha1.ModeRecommend,
				v1alpha1.ModeDisabled,
			}

			for i, mode := range validModes {
				config := helpers.PolicyConfig{
					Name: fmt.Sprintf("mode-test-%d", i),
					Mode: mode,
					NamespaceSelector: map[string]string{
						"test": "mode",
					},
					WorkloadSelector: map[string]string{
						"mode": string(mode),
					},
					ResourceBounds: helpers.ResourceBounds{
						CPU: helpers.ResourceBound{
							Min: "100m",
							Max: "500m",
						},
						Memory: helpers.ResourceBound{
							Min: "128Mi",
							Max: "512Mi",
						},
					},
					MetricsConfig: helpers.MetricsConfig{
						Provider:      "metrics-server",
						RollingWindow: "1h",
						Percentile:    "P90",
						SafetyFactor:  1.0,
					},
					UpdateStrategy: helpers.UpdateStrategy{
						AllowInPlaceResize: true,
						AllowRecreate:      false,
						UpdateRequestsOnly: true,
					},
				}

				policy, err := policyHelper.CreateOptimizationPolicy(config)
				Expect(err).NotTo(HaveOccurred())
				Expect(policy.Spec.Mode).To(Equal(mode))
				cleanupHelper.TrackPolicy(policy.Name, policy.Namespace)
			}
		})

		It("should validate workload selector logic", func() {
			By("testing label selector creation")
			namespaceLabels := map[string]string{
				"environment": "production",
				"team":        "platform",
			}
			workloadLabels := map[string]string{
				"optimize": "true",
				"tier":     "frontend",
			}

			config := helpers.PolicyConfig{
				Name:              "selector-test",
				Mode:              v1alpha1.ModeRecommend,
				NamespaceSelector: namespaceLabels,
				WorkloadSelector:  workloadLabels,
				ResourceBounds: helpers.ResourceBounds{
					CPU: helpers.ResourceBound{
						Min: "100m",
						Max: "1000m",
					},
					Memory: helpers.ResourceBound{
						Min: "128Mi",
						Max: "1Gi",
					},
				},
				MetricsConfig: helpers.MetricsConfig{
					Provider:      "metrics-server",
					RollingWindow: "1h",
					Percentile:    "P90",
					SafetyFactor:  1.2,
				},
				UpdateStrategy: helpers.UpdateStrategy{
					AllowInPlaceResize: true,
					AllowRecreate:      false,
					UpdateRequestsOnly: true,
				},
			}

			policy, err := policyHelper.CreateOptimizationPolicy(config)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackPolicy(policy.Name, policy.Namespace)

			// Validate selectors are properly set
			Expect(policy.Spec.Selector.NamespaceSelector).NotTo(BeNil())
			Expect(policy.Spec.Selector.NamespaceSelector.MatchLabels).To(Equal(namespaceLabels))
			Expect(policy.Spec.Selector.WorkloadSelector).NotTo(BeNil())
			Expect(policy.Spec.Selector.WorkloadSelector.MatchLabels).To(Equal(workloadLabels))

			By("testing empty selector handling")
			emptyConfig := config
			emptyConfig.Name = "empty-selector-test"
			emptyConfig.NamespaceSelector = nil
			emptyConfig.WorkloadSelector = map[string]string{
				"test": "empty",
			}

			emptyPolicy, err := policyHelper.CreateOptimizationPolicy(emptyConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackPolicy(emptyPolicy.Name, emptyPolicy.Namespace)

			// Should have nil namespace selector but valid workload selector
			Expect(emptyPolicy.Spec.Selector.NamespaceSelector).To(BeNil())
			Expect(emptyPolicy.Spec.Selector.WorkloadSelector).NotTo(BeNil())
			Expect(emptyPolicy.Spec.Selector.WorkloadSelector.MatchLabels).To(Equal(map[string]string{"test": "empty"}))
		})
	})
})
