//go:build e2e
// +build e2e

/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package e2e

import (
	"context"
	"fmt"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/optipod/optipod/api/v1alpha1"
	"github.com/optipod/optipod/test/e2e/helpers"

	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/kubernetes/scheme"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/config"
)

var _ = Describe("RBAC and Security Constraints", Ordered, func() {
	var (
		k8sClient       client.Client
		testNamespace   string
		policyNamespace string
		policyHelper    *helpers.PolicyHelper
		cleanupHelper   *helpers.CleanupHelper
		rbacHelper      *RBACHelper
	)

	BeforeAll(func() {
		By("setting up test environment")

		// Initialize Kubernetes client
		cfg, err := config.GetConfig()
		Expect(err).NotTo(HaveOccurred())

		// Add OptipPod scheme
		s := runtime.NewScheme()
		Expect(scheme.AddToScheme(s)).To(Succeed())
		Expect(v1alpha1.AddToScheme(s)).To(Succeed())

		k8sClient, err = client.New(cfg, client.Options{Scheme: s})
		Expect(err).NotTo(HaveOccurred())

		// Set up namespaces
		testNamespace = "rbac-security-test"
		policyNamespace = "optipod-system"

		// Initialize helpers
		policyHelper = helpers.NewPolicyHelper(k8sClient, policyNamespace)
		cleanupHelper = helpers.NewCleanupHelper(k8sClient)
		rbacHelper = NewRBACHelper(k8sClient, cleanupHelper)

		// Create test namespace
		testNs := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNamespace,
				Labels: map[string]string{
					"rbac-test": "true",
				},
			},
		}
		err = k8sClient.Create(context.TODO(), testNs)
		if err != nil && !errors.IsAlreadyExists(err) {
			Expect(err).NotTo(HaveOccurred(), "Failed to create test namespace")
		}
		cleanupHelper.TrackNamespace(testNamespace)
	})

	AfterAll(func() {
		By("cleaning up test resources")
		err := cleanupHelper.CleanupAll()
		Expect(err).NotTo(HaveOccurred(), "Failed to cleanup test resources")
	})

	Context("Restricted Service Account Scenarios", func() {
		It("should handle insufficient permissions gracefully", func() {
			By("Creating a service account with limited permissions")
			saName := "limited-optipod-sa"
			sa, err := rbacHelper.CreateRestrictedServiceAccount(saName, testNamespace, []string{"get", "list"})
			Expect(err).NotTo(HaveOccurred())
			Expect(sa).NotTo(BeNil())

			By("Creating an OptimizationPolicy")
			policyConfig := helpers.PolicyConfig{
				Name: "test-policy-restricted",
				Mode: v1alpha1.ModeAuto,
				NamespaceSelector: map[string]string{
					"optipod-test": "rbac",
				},
				WorkloadSelector: map[string]string{
					"app": "test-workload",
				},
				ResourceBounds: helpers.ResourceBounds{
					CPU: helpers.ResourceBound{
						Min: "100m",
						Max: "1000m",
					},
					Memory: helpers.ResourceBound{
						Min: "128Mi",
						Max: "1Gi",
					},
				},
				MetricsConfig: helpers.MetricsConfig{
					Provider:      "prometheus",
					RollingWindow: "5m",
					Percentile:    "95",
					SafetyFactor:  1.2,
				},
				UpdateStrategy: helpers.UpdateStrategy{
					AllowInPlaceResize: true,
					AllowRecreate:      false,
					UpdateRequestsOnly: false,
				},
			}

			policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackPolicy(policy.Name, policy.Namespace)

			By("Verifying that the controller handles permission errors appropriately")
			err = rbacHelper.ValidateServiceAccountPermissions(saName, testNamespace, []string{"get", "list"})
			Expect(err).NotTo(HaveOccurred())
		})

		It("should prevent permission escalation", func() {
			By("Creating a service account with minimal permissions")
			saName := "minimal-optipod-sa"
			sa, err := rbacHelper.CreateRestrictedServiceAccount(saName, testNamespace, []string{"get"})
			Expect(err).NotTo(HaveOccurred())
			Expect(sa).NotTo(BeNil())

			By("Verifying that the service account cannot escalate permissions")
			err = rbacHelper.ValidateNoPermissionEscalation(saName, testNamespace)
			Expect(err).NotTo(HaveOccurred())

			By("Verifying that unauthorized operations are blocked")
			err = rbacHelper.ValidateUnauthorizedOperationsBlocked(saName, testNamespace)
			Expect(err).NotTo(HaveOccurred())
		})

		It("should handle read-only service account permissions", func() {
			By("Creating a read-only service account")
			saName := "readonly-optipod-sa"
			sa, err := rbacHelper.CreateReadOnlyServiceAccount(saName, testNamespace)
			Expect(err).NotTo(HaveOccurred())
			Expect(sa).NotTo(BeNil())

			By("Verifying read-only permissions are correctly configured")
			err = rbacHelper.ValidateReadOnlyPermissions(saName, testNamespace)
			Expect(err).NotTo(HaveOccurred())

			By("Verifying that write operations are blocked")
			err = rbacHelper.ValidateWriteOperationsBlocked(saName, testNamespace)
			Expect(err).NotTo(HaveOccurred())
		})
	})

	Context("RBAC Lifecycle Property Tests", func() {
		DescribeTable("RBAC lifecycle management property",
			func(saName string, permissions []string, shouldHaveOptipPodAccess bool) {
				// **Feature: e2e-test-enhancement, Property 4: RBAC lifecycle management**
				// For any RBAC test scenario, service accounts and role bindings should be created with correct permissions, tested for expected behavior, and completely cleaned up afterward

				By(fmt.Sprintf("Creating service account %s with permissions %v", saName, permissions))
				var sa *corev1.ServiceAccount
				var err error

				if shouldHaveOptipPodAccess {
					sa, err = rbacHelper.CreateRestrictedServiceAccount(saName, testNamespace, permissions)
				} else {
					// Create service account without OptipPod permissions
					sa = &corev1.ServiceAccount{
						ObjectMeta: metav1.ObjectMeta{
							Name:      saName,
							Namespace: testNamespace,
						},
					}
					err = k8sClient.Create(context.TODO(), sa)
					if err != nil {
						Expect(err).NotTo(HaveOccurred(), "Failed to create service account")
					}
					cleanupHelper.TrackServiceAccount(saName, testNamespace)
				}
				Expect(err).NotTo(HaveOccurred())
				Expect(sa).NotTo(BeNil())

				By("Validating service account permissions are correctly configured")
				if shouldHaveOptipPodAccess {
					err = rbacHelper.ValidateServiceAccountPermissions(saName, testNamespace, permissions)
					Expect(err).NotTo(HaveOccurred())
				}

				By("Validating no permission escalation is possible")
				if shouldHaveOptipPodAccess {
					err = rbacHelper.ValidateNoPermissionEscalation(saName, testNamespace)
					Expect(err).NotTo(HaveOccurred())
				}

				By("Validating unauthorized operations are blocked")
				err = rbacHelper.ValidateUnauthorizedOperationsBlocked(saName, testNamespace)
				Expect(err).NotTo(HaveOccurred())

				By("Validating that cleanup will be complete")
				// Verify resources exist before cleanup
				retrievedSA := &corev1.ServiceAccount{}
				err = k8sClient.Get(context.TODO(), types.NamespacedName{
					Name:      saName,
					Namespace: testNamespace,
				}, retrievedSA)
				Expect(err).NotTo(HaveOccurred(), "Service account should exist before cleanup")
			},
			Entry("read-only permissions", "readonly-sa", []string{"get", "list", "watch"}, true),
			Entry("limited permissions", "limited-sa", []string{"get", "list"}, true),
			Entry("minimal permissions", "minimal-sa", []string{"get"}, true),
			Entry("no OptipPod permissions", "no-optipod-sa", []string{}, false),
		)
	})

	Context("Security Constraint Validation", func() {
		It("should respect pod security policies", func() {
			By("Creating a policy with security constraints")
			policyConfig := helpers.PolicyConfig{
				Name: "security-constrained-policy",
				Mode: v1alpha1.ModeRecommend,
				NamespaceSelector: map[string]string{
					"security-test": "enabled",
				},
				WorkloadSelector: map[string]string{
					"security": "constrained",
				},
				ResourceBounds: helpers.ResourceBounds{
					CPU: helpers.ResourceBound{
						Min: "100m",
						Max: "500m",
					},
					Memory: helpers.ResourceBound{
						Min: "64Mi",
						Max: "512Mi",
					},
				},
				MetricsConfig: helpers.MetricsConfig{
					Provider:      "prometheus",
					RollingWindow: "5m",
					Percentile:    "95",
					SafetyFactor:  1.1,
				},
				UpdateStrategy: helpers.UpdateStrategy{
					AllowInPlaceResize: true,
					AllowRecreate:      false,
					UpdateRequestsOnly: true,
				},
			}

			policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackPolicy(policy.Name, policy.Namespace)

			By("Verifying security constraints in policy spec")
			Expect(policy.Spec.UpdateStrategy.UpdateRequestsOnly).To(BeTrue(), "Policy should use requests-only updates for security")
			Expect(policy.Spec.UpdateStrategy.AllowRecreate).To(BeFalse(), "Policy should not allow recreation for security")
		})

		It("should validate resource bounds for security", func() {
			By("Creating a policy with strict resource bounds")
			policyConfig := helpers.PolicyConfig{
				Name: "strict-security-policy",
				Mode: v1alpha1.ModeRecommend,
				NamespaceSelector: map[string]string{
					"security-strict": "enabled",
				},
				WorkloadSelector: map[string]string{
					"security-level": "strict",
				},
				ResourceBounds: helpers.ResourceBounds{
					CPU: helpers.ResourceBound{
						Min: "50m",
						Max: "200m",
					},
					Memory: helpers.ResourceBound{
						Min: "32Mi",
						Max: "256Mi",
					},
				},
				MetricsConfig: helpers.MetricsConfig{
					Provider:      "prometheus",
					RollingWindow: "5m",
					Percentile:    "90",
					SafetyFactor:  1.0,
				},
				UpdateStrategy: helpers.UpdateStrategy{
					AllowInPlaceResize: true,
					AllowRecreate:      false,
					UpdateRequestsOnly: true,
				},
			}

			policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackPolicy(policy.Name, policy.Namespace)

			By("Verifying strict resource bounds")
			Expect(policy.Spec.ResourceBounds.CPU.Min.String()).To(Equal("50m"), "Policy should have minimum CPU bound")
			Expect(policy.Spec.ResourceBounds.CPU.Max.String()).To(Equal("200m"), "Policy should have maximum CPU bound")
			Expect(policy.Spec.ResourceBounds.Memory.Min.String()).To(Equal("32Mi"), "Policy should have minimum memory bound")
			Expect(policy.Spec.ResourceBounds.Memory.Max.String()).To(Equal("256Mi"), "Policy should have maximum memory bound")
		})
	})

	Context("Security Compliance Property Tests", func() {
		DescribeTable("security constraint compliance property",
			func(policyMode v1alpha1.PolicyMode, updateRequestsOnly bool, allowRecreate bool, cpuMin, cpuMax, memMin, memMax, expectedSecurityLevel string) {
				// **Feature: e2e-test-enhancement, Property 5: Security constraint compliance**
				// For any security policy configuration, OptipPod should respect pod security policies and report clear error messages when constraints are violated

				By(fmt.Sprintf("Creating policy with mode %s and security level %s", policyMode, expectedSecurityLevel))
				policyConfig := helpers.PolicyConfig{
					Name: fmt.Sprintf("security-compliance-%s", expectedSecurityLevel),
					Mode: policyMode,
					NamespaceSelector: map[string]string{
						"security-compliance": "test",
						"security-level":      expectedSecurityLevel,
					},
					WorkloadSelector: map[string]string{
						"security-test": "enabled",
					},
					ResourceBounds: helpers.ResourceBounds{
						CPU: helpers.ResourceBound{
							Min: cpuMin,
							Max: cpuMax,
						},
						Memory: helpers.ResourceBound{
							Min: memMin,
							Max: memMax,
						},
					},
					MetricsConfig: helpers.MetricsConfig{
						Provider:      "prometheus",
						RollingWindow: "5m",
						Percentile:    "95",
						SafetyFactor:  1.1,
					},
					UpdateStrategy: helpers.UpdateStrategy{
						AllowInPlaceResize: true,
						AllowRecreate:      allowRecreate,
						UpdateRequestsOnly: updateRequestsOnly,
					},
				}

				policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
				Expect(err).NotTo(HaveOccurred(), "Failed to create security compliance policy")
				cleanupHelper.TrackPolicy(policy.Name, policy.Namespace)

				By("Validating policy was created with correct security settings")
				Expect(policy.Spec.Mode).To(Equal(policyMode), "Policy should have correct mode")
				Expect(policy.Spec.UpdateStrategy.UpdateRequestsOnly).To(Equal(updateRequestsOnly), "Policy should have correct updateRequestsOnly setting")
				Expect(policy.Spec.UpdateStrategy.AllowRecreate).To(Equal(allowRecreate), "Policy should have correct allowRecreate setting")

				if expectedSecurityLevel == "strict" {
					By("Validating strict security constraints")
					Expect(updateRequestsOnly).To(BeTrue(), "Strict security should use requests-only updates")
					Expect(allowRecreate).To(BeFalse(), "Strict security should not allow recreation")
				}

				if expectedSecurityLevel == "restricted" {
					By("Validating restricted security constraints")
					Expect(policy.Spec.ResourceBounds.CPU.Max.String()).To(Equal(cpuMax), "Policy should have correct CPU max")
					Expect(policy.Spec.ResourceBounds.Memory.Max.String()).To(Equal(memMax), "Policy should have correct memory max")
				}
			},
			Entry("Auto mode with strict security", v1alpha1.ModeAuto, true, false, "50m", "200m", "32Mi", "256Mi", "strict"),
			Entry("Recommend mode with restricted security", v1alpha1.ModeRecommend, false, false, "100m", "1000m", "128Mi", "1Gi", "restricted"),
			Entry("Disabled mode with permissive security", v1alpha1.ModeDisabled, false, false, "100m", "2000m", "128Mi", "4Gi", "permissive"),
			Entry("Auto mode with high resource bounds", v1alpha1.ModeAuto, false, true, "1000m", "4000m", "1Gi", "8Gi", "high-resource"),
		)
	})
})

// RBACHelper provides utilities for RBAC and security testing
type RBACHelper struct {
	client        client.Client
	cleanupHelper *helpers.CleanupHelper
}

// NewRBACHelper creates a new RBACHelper instance
func NewRBACHelper(client client.Client, cleanupHelper *helpers.CleanupHelper) *RBACHelper {
	return &RBACHelper{
		client:        client,
		cleanupHelper: cleanupHelper,
	}
}

// CreateRestrictedServiceAccount creates a service account with limited permissions
func (h *RBACHelper) CreateRestrictedServiceAccount(name, namespace string, verbs []string) (*corev1.ServiceAccount, error) {
	// Create ServiceAccount
	sa := &corev1.ServiceAccount{
		ObjectMeta: metav1.ObjectMeta{
			Name:      name,
			Namespace: namespace,
		},
	}

	err := h.client.Create(context.TODO(), sa)
	if err != nil {
		return nil, fmt.Errorf("failed to create service account: %w", err)
	}
	h.cleanupHelper.TrackServiceAccount(name, namespace)

	// Create Role with limited permissions
	roleName := fmt.Sprintf("%s-role", name)
	role := &rbacv1.Role{
		ObjectMeta: metav1.ObjectMeta{
			Name:      roleName,
			Namespace: namespace,
		},
		Rules: []rbacv1.PolicyRule{
			{
				APIGroups: []string{""},
				Resources: []string{"pods", "services"},
				Verbs:     verbs,
			},
			{
				APIGroups: []string{"apps"},
				Resources: []string{"deployments", "statefulsets", "daemonsets"},
				Verbs:     verbs,
			},
			{
				APIGroups: []string{"optipod.optipod.io"},
				Resources: []string{"optimizationpolicies"},
				Verbs:     verbs,
			},
		},
	}

	err = h.client.Create(context.TODO(), role)
	if err != nil {
		return nil, fmt.Errorf("failed to create role: %w", err)
	}

	// Create RoleBinding
	roleBindingName := fmt.Sprintf("%s-binding", name)
	roleBinding := &rbacv1.RoleBinding{
		ObjectMeta: metav1.ObjectMeta{
			Name:      roleBindingName,
			Namespace: namespace,
		},
		Subjects: []rbacv1.Subject{
			{
				Kind:      "ServiceAccount",
				Name:      name,
				Namespace: namespace,
			},
		},
		RoleRef: rbacv1.RoleRef{
			APIGroup: "rbac.authorization.k8s.io",
			Kind:     "Role",
			Name:     roleName,
		},
	}

	err = h.client.Create(context.TODO(), roleBinding)
	if err != nil {
		return nil, fmt.Errorf("failed to create role binding: %w", err)
	}

	return sa, nil
}

// ValidateServiceAccountPermissions validates that a service account has the expected permissions
func (h *RBACHelper) ValidateServiceAccountPermissions(saName, namespace string, expectedVerbs []string) error {
	// Get the role associated with the service account
	roleName := fmt.Sprintf("%s-role", saName)
	role := &rbacv1.Role{}
	err := h.client.Get(context.TODO(), types.NamespacedName{
		Name:      roleName,
		Namespace: namespace,
	}, role)
	if err != nil {
		return fmt.Errorf("failed to get role: %w", err)
	}

	// Validate that the role has the expected verbs
	for _, expectedVerb := range expectedVerbs {
		found := false
		for _, rule := range role.Rules {
			for _, verb := range rule.Verbs {
				if verb == expectedVerb {
					found = true
					break
				}
			}
			if found {
				break
			}
		}
		if !found {
			return fmt.Errorf("expected verb %s not found in role rules", expectedVerb)
		}
	}

	return nil
}

// ValidateNoPermissionEscalation validates that a service account cannot escalate permissions
func (h *RBACHelper) ValidateNoPermissionEscalation(saName, namespace string) error {
	// Get the role associated with the service account
	roleName := fmt.Sprintf("%s-role", saName)
	role := &rbacv1.Role{}
	err := h.client.Get(context.TODO(), types.NamespacedName{
		Name:      roleName,
		Namespace: namespace,
	}, role)
	if err != nil {
		return fmt.Errorf("failed to get role: %w", err)
	}

	// Check that the role doesn't have escalation permissions
	prohibitedVerbs := []string{"create", "update", "patch", "delete", "escalate", "bind"}
	prohibitedResources := []string{"roles", "rolebindings", "clusterroles", "clusterrolebindings"}

	for _, rule := range role.Rules {
		for _, resource := range rule.Resources {
			for _, prohibitedResource := range prohibitedResources {
				if resource == prohibitedResource {
					for _, verb := range rule.Verbs {
						for _, prohibitedVerb := range prohibitedVerbs {
							if verb == prohibitedVerb {
								return fmt.Errorf("role has escalation permission: %s on %s", verb, resource)
							}
						}
					}
				}
			}
		}
	}

	return nil
}

// ValidateUnauthorizedOperationsBlocked validates that unauthorized operations are blocked
func (h *RBACHelper) ValidateUnauthorizedOperationsBlocked(saName, namespace string) error {
	// Validate that the service account doesn't have cluster-admin permissions
	clusterRoleBindings := &rbacv1.ClusterRoleBindingList{}
	err := h.client.List(context.TODO(), clusterRoleBindings)
	if err != nil {
		return fmt.Errorf("failed to list cluster role bindings: %w", err)
	}

	for _, binding := range clusterRoleBindings.Items {
		if binding.RoleRef.Name == "cluster-admin" {
			for _, subject := range binding.Subjects {
				if subject.Kind == "ServiceAccount" && subject.Name == saName && subject.Namespace == namespace {
					return fmt.Errorf("service account has cluster-admin permissions")
				}
			}
		}
	}

	return nil
}

// CreateReadOnlyServiceAccount creates a service account with read-only permissions
func (h *RBACHelper) CreateReadOnlyServiceAccount(name, namespace string) (*corev1.ServiceAccount, error) {
	return h.CreateRestrictedServiceAccount(name, namespace, []string{"get", "list", "watch"})
}

// ValidateReadOnlyPermissions validates that a service account has only read permissions
func (h *RBACHelper) ValidateReadOnlyPermissions(saName, namespace string) error {
	expectedVerbs := []string{"get", "list", "watch"}
	return h.ValidateServiceAccountPermissions(saName, namespace, expectedVerbs)
}

// ValidateWriteOperationsBlocked validates that write operations are blocked for a service account
func (h *RBACHelper) ValidateWriteOperationsBlocked(saName, namespace string) error {
	// Get the role associated with the service account
	roleName := fmt.Sprintf("%s-role", saName)
	role := &rbacv1.Role{}
	err := h.client.Get(context.TODO(), types.NamespacedName{
		Name:      roleName,
		Namespace: namespace,
	}, role)
	if err != nil {
		return fmt.Errorf("failed to get role: %w", err)
	}

	// Check that the role doesn't have write permissions
	prohibitedVerbs := []string{"create", "update", "patch", "delete"}

	for _, rule := range role.Rules {
		for _, verb := range rule.Verbs {
			for _, prohibitedVerb := range prohibitedVerbs {
				if verb == prohibitedVerb {
					return fmt.Errorf("role has write permission: %s", verb)
				}
			}
		}
	}

	return nil
}
