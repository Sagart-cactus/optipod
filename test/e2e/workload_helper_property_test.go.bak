//go:build e2e
// +build e2e

package e2e

import (
	"context"
	"fmt"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/optipod/optipod/test/e2e/fixtures"
	"github.com/optipod/optipod/test/e2e/helpers"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
)

var _ = Describe("WorkloadHelper Property Tests", func() {
	var (
		workloadHelper *helpers.WorkloadHelper
		cleanupHelper  *helpers.CleanupHelper
		testNamespace  string
		generator      *fixtures.WorkloadConfigGenerator
	)

	BeforeEach(func() {
		testNamespace = "test-workloads"

		// Create test namespace if it doesn't exist
		namespace := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNamespace,
				Labels: map[string]string{
					"environment": "test",
				},
			},
		}
		err := k8sClient.Create(context.TODO(), namespace)
		if err != nil && !errors.IsAlreadyExists(err) {
			Expect(err).NotTo(HaveOccurred(), "Failed to create test namespace")
		}

		workloadHelper = helpers.NewWorkloadHelper(k8sClient, testNamespace)
		cleanupHelper = helpers.NewCleanupHelper(k8sClient)
		cleanupHelper.TrackNamespace(testNamespace)
		generator = fixtures.NewWorkloadConfigGenerator()
	})

	AfterEach(func() {
		err := cleanupHelper.CleanupNamespace(testNamespace)
		Expect(err).NotTo(HaveOccurred(), "Failed to cleanup test namespace")
	})

	Context("Property 9: Workload type consistency", func() {
		// **Feature: e2e-test-enhancement, Property 9: Workload type consistency**
		// **Validates: Requirements 5.1, 5.3**

		DescribeTable("Workload behavior should be consistent across all supported types",
			func(workloadType helpers.WorkloadType) {
				By(fmt.Sprintf("Testing workload type: %s", workloadType))

				// Generate workload configuration
				workloadConfig := generator.GenerateBasicWorkloadConfig(
					fmt.Sprintf("property-test-%s", toLowerCase(string(workloadType))),
					workloadType,
				)

				// Create the workload
				var err error
				switch workloadType {
				case helpers.WorkloadTypeDeployment:
					deployment, createErr := workloadHelper.CreateDeployment(workloadConfig)
					err = createErr
					if err == nil {
						cleanupHelper.TrackDeployment(deployment.Name, deployment.Namespace)
					}

				case helpers.WorkloadTypeStatefulSet:
					statefulSet, createErr := workloadHelper.CreateStatefulSet(workloadConfig)
					err = createErr
					if err == nil {
						cleanupHelper.TrackStatefulSet(statefulSet.Name, statefulSet.Namespace)
					}

				case helpers.WorkloadTypeDaemonSet:
					daemonSet, createErr := workloadHelper.CreateDaemonSet(workloadConfig)
					err = createErr
					if err == nil {
						cleanupHelper.TrackDaemonSet(daemonSet.Name, daemonSet.Namespace)
					}
				}

				Expect(err).NotTo(HaveOccurred(), "Failed to create workload")

				// Wait for workload to be ready
				err = workloadHelper.WaitForWorkloadReady(workloadConfig.Name, workloadType, 3*time.Minute)
				Expect(err).NotTo(HaveOccurred(), "Workload should become ready")

				// Verify workload annotations can be retrieved
				annotations, err := workloadHelper.GetWorkloadAnnotations(workloadConfig.Name, workloadType)
				Expect(err).NotTo(HaveOccurred(), "Should be able to get workload annotations")
				Expect(annotations).NotTo(BeNil(), "Annotations should not be nil")

				// Verify workload has expected labels
				switch workloadType {
				case helpers.WorkloadTypeDeployment:
					deployment := &appsv1.Deployment{}
					err = k8sClient.Get(context.TODO(), types.NamespacedName{
						Name:      workloadConfig.Name,
						Namespace: testNamespace,
					}, deployment)
					Expect(err).NotTo(HaveOccurred(), "Should retrieve deployment")
					Expect(deployment.Labels).To(Equal(workloadConfig.Labels), "Labels should match")

				case helpers.WorkloadTypeStatefulSet:
					statefulSet := &appsv1.StatefulSet{}
					err = k8sClient.Get(context.TODO(), types.NamespacedName{
						Name:      workloadConfig.Name,
						Namespace: testNamespace,
					}, statefulSet)
					Expect(err).NotTo(HaveOccurred(), "Should retrieve statefulset")
					Expect(statefulSet.Labels).To(Equal(workloadConfig.Labels), "Labels should match")

				case helpers.WorkloadTypeDaemonSet:
					daemonSet := &appsv1.DaemonSet{}
					err = k8sClient.Get(context.TODO(), types.NamespacedName{
						Name:      workloadConfig.Name,
						Namespace: testNamespace,
					}, daemonSet)
					Expect(err).NotTo(HaveOccurred(), "Should retrieve daemonset")
					Expect(daemonSet.Labels).To(Equal(workloadConfig.Labels), "Labels should match")
				}
			},
			Entry("Deployment", helpers.WorkloadTypeDeployment),
			Entry("StatefulSet", helpers.WorkloadTypeStatefulSet),
			Entry("DaemonSet", helpers.WorkloadTypeDaemonSet),
		)

		It("should handle resource specifications consistently across workload types", func() {
			workloadTypes := []helpers.WorkloadType{
				helpers.WorkloadTypeDeployment,
				helpers.WorkloadTypeStatefulSet,
				helpers.WorkloadTypeDaemonSet,
			}

			resourceConfigs := []helpers.ResourceRequirements{
				{
					Requests: helpers.ResourceList{CPU: "100m", Memory: "128Mi"},
					Limits:   helpers.ResourceList{CPU: "200m", Memory: "256Mi"},
				},
				{
					Requests: helpers.ResourceList{CPU: "500m", Memory: "512Mi"},
					Limits:   helpers.ResourceList{CPU: "1000m", Memory: "1Gi"},
				},
				{
					Requests: helpers.ResourceList{CPU: "1000m", Memory: "1Gi"},
					Limits:   helpers.ResourceList{CPU: "2000m", Memory: "2Gi"},
				},
			}

			for i, workloadType := range workloadTypes {
				for j, resourceConfig := range resourceConfigs {
					By(fmt.Sprintf("Testing %s with resource config %d", workloadType, j))

					workloadName := fmt.Sprintf("resource-test-%s-%d", toLowerCase(string(workloadType)), j)
					workloadConfig := generator.GenerateBasicWorkloadConfig(workloadName, workloadType)
					workloadConfig.Resources = resourceConfig

					// Create workload
					var err error
					switch workloadType {
					case helpers.WorkloadTypeDeployment:
						deployment, createErr := workloadHelper.CreateDeployment(workloadConfig)
						err = createErr
						if err == nil {
							cleanupHelper.TrackDeployment(deployment.Name, deployment.Namespace)
						}

					case helpers.WorkloadTypeStatefulSet:
						statefulSet, createErr := workloadHelper.CreateStatefulSet(workloadConfig)
						err = createErr
						if err == nil {
							cleanupHelper.TrackStatefulSet(statefulSet.Name, statefulSet.Namespace)
						}

					case helpers.WorkloadTypeDaemonSet:
						daemonSet, createErr := workloadHelper.CreateDaemonSet(workloadConfig)
						err = createErr
						if err == nil {
							cleanupHelper.TrackDaemonSet(daemonSet.Name, daemonSet.Namespace)
						}
					}

					Expect(err).NotTo(HaveOccurred(), "Failed to create workload")

					// Wait for workload to be ready
					err = workloadHelper.WaitForWorkloadReady(workloadName, workloadType, 3*time.Minute)
					Expect(err).NotTo(HaveOccurred(), "Workload should become ready")

					// Verify resource specifications are applied correctly
					switch workloadType {
					case helpers.WorkloadTypeDeployment:
						deployment := &appsv1.Deployment{}
						err = k8sClient.Get(context.TODO(), types.NamespacedName{
							Name:      workloadName,
							Namespace: testNamespace,
						}, deployment)
						Expect(err).NotTo(HaveOccurred(), "Should retrieve deployment")

						container := deployment.Spec.Template.Spec.Containers[0]
						if resourceConfig.Requests.CPU != "" {
							Expect(container.Resources.Requests.Cpu().String()).To(Equal(resourceConfig.Requests.CPU), "CPU request should match")
						}
						if resourceConfig.Requests.Memory != "" {
							Expect(container.Resources.Requests.Memory().String()).To(Equal(resourceConfig.Requests.Memory), "Memory request should match")
						}

					case helpers.WorkloadTypeStatefulSet:
						statefulSet := &appsv1.StatefulSet{}
						err = k8sClient.Get(context.TODO(), types.NamespacedName{
							Name:      workloadName,
							Namespace: testNamespace,
						}, statefulSet)
						Expect(err).NotTo(HaveOccurred(), "Should retrieve statefulset")

						container := statefulSet.Spec.Template.Spec.Containers[0]
						if resourceConfig.Requests.CPU != "" {
							Expect(container.Resources.Requests.Cpu().String()).To(Equal(resourceConfig.Requests.CPU), "CPU request should match")
						}
						if resourceConfig.Requests.Memory != "" {
							Expect(container.Resources.Requests.Memory().String()).To(Equal(resourceConfig.Requests.Memory), "Memory request should match")
						}

					case helpers.WorkloadTypeDaemonSet:
						daemonSet := &appsv1.DaemonSet{}
						err = k8sClient.Get(context.TODO(), types.NamespacedName{
							Name:      workloadName,
							Namespace: testNamespace,
						}, daemonSet)
						Expect(err).NotTo(HaveOccurred(), "Should retrieve daemonset")

						container := daemonSet.Spec.Template.Spec.Containers[0]
						if resourceConfig.Requests.CPU != "" {
							Expect(container.Resources.Requests.Cpu().String()).To(Equal(resourceConfig.Requests.CPU), "CPU request should match")
						}
						if resourceConfig.Requests.Memory != "" {
							Expect(container.Resources.Requests.Memory().String()).To(Equal(resourceConfig.Requests.Memory), "Memory request should match")
						}
					}
				}
			}
		})

		It("should maintain workload lifecycle consistency across types", func() {
			workloadTypes := []helpers.WorkloadType{
				helpers.WorkloadTypeDeployment,
				helpers.WorkloadTypeStatefulSet,
				helpers.WorkloadTypeDaemonSet,
			}

			for i, workloadType := range workloadTypes {
				By(fmt.Sprintf("Testing lifecycle for %s", workloadType))

				workloadName := fmt.Sprintf("lifecycle-test-%s", toLowerCase(string(workloadType)))
				workloadConfig := generator.GenerateBasicWorkloadConfig(workloadName, workloadType)

				// Create workload
				var err error
				switch workloadType {
				case helpers.WorkloadTypeDeployment:
					deployment, createErr := workloadHelper.CreateDeployment(workloadConfig)
					err = createErr
					if err == nil {
						cleanupHelper.TrackDeployment(deployment.Name, deployment.Namespace)
					}

				case helpers.WorkloadTypeStatefulSet:
					statefulSet, createErr := workloadHelper.CreateStatefulSet(workloadConfig)
					err = createErr
					if err == nil {
						cleanupHelper.TrackStatefulSet(statefulSet.Name, statefulSet.Namespace)
					}

				case helpers.WorkloadTypeDaemonSet:
					daemonSet, createErr := workloadHelper.CreateDaemonSet(workloadConfig)
					err = createErr
					if err == nil {
						cleanupHelper.TrackDaemonSet(daemonSet.Name, daemonSet.Namespace)
					}
				}

				Expect(err).NotTo(HaveOccurred(), "Failed to create workload")

				// Wait for workload to be ready
				err = workloadHelper.WaitForWorkloadReady(workloadName, workloadType, 3*time.Minute)
				Expect(err).NotTo(HaveOccurred(), "Workload should become ready")

				// Test annotation retrieval
				annotations, err := workloadHelper.GetWorkloadAnnotations(workloadName, workloadType)
				Expect(err).NotTo(HaveOccurred(), "Should get annotations")
				Expect(annotations).NotTo(BeNil(), "Annotations should not be nil")

				// Test workload deletion
				err = workloadHelper.DeleteWorkload(workloadName, workloadType)
				Expect(err).NotTo(HaveOccurred(), "Should delete workload")

				// Verify workload is deleted
				Eventually(func() bool {
					switch workloadType {
					case helpers.WorkloadTypeDeployment:
						deployment := &appsv1.Deployment{}
						err = k8sClient.Get(context.TODO(), types.NamespacedName{
							Name:      workloadName,
							Namespace: testNamespace,
						}, deployment)
						return errors.IsNotFound(err)

					case helpers.WorkloadTypeStatefulSet:
						statefulSet := &appsv1.StatefulSet{}
						err = k8sClient.Get(context.TODO(), types.NamespacedName{
							Name:      workloadName,
							Namespace: testNamespace,
						}, statefulSet)
						return errors.IsNotFound(err)

					case helpers.WorkloadTypeDaemonSet:
						daemonSet := &appsv1.DaemonSet{}
						err = k8sClient.Get(context.TODO(), types.NamespacedName{
							Name:      workloadName,
							Namespace: testNamespace,
						}, daemonSet)
						return errors.IsNotFound(err)
					}
					return false
				}, 2*time.Minute, 5*time.Second).Should(BeTrue(), "Workload should be deleted")
			}
		})

		It("should handle random workload configurations consistently", func() {
			// Test with multiple random configurations
			for i := 0; i < 10; i++ {
				By(fmt.Sprintf("Testing random configuration %d", i))

				// Generate random workload configuration
				workloadConfig := generator.GenerateRandomWorkloadConfig(fmt.Sprintf("random-test-%d", i))

				// Create workload based on type
				var err error
				switch workloadConfig.Type {
				case helpers.WorkloadTypeDeployment:
					deployment, createErr := workloadHelper.CreateDeployment(workloadConfig)
					err = createErr
					if err == nil {
						cleanupHelper.TrackDeployment(deployment.Name, deployment.Namespace)
					}

				case helpers.WorkloadTypeStatefulSet:
					statefulSet, createErr := workloadHelper.CreateStatefulSet(workloadConfig)
					err = createErr
					if err == nil {
						cleanupHelper.TrackStatefulSet(statefulSet.Name, statefulSet.Namespace)
					}

				case helpers.WorkloadTypeDaemonSet:
					daemonSet, createErr := workloadHelper.CreateDaemonSet(workloadConfig)
					err = createErr
					if err == nil {
						cleanupHelper.TrackDaemonSet(daemonSet.Name, daemonSet.Namespace)
					}
				}

				Expect(err).NotTo(HaveOccurred(), "Failed to create random workload")

				// Wait for workload to be ready
				err = workloadHelper.WaitForWorkloadReady(workloadConfig.Name, workloadConfig.Type, 3*time.Minute)
				Expect(err).NotTo(HaveOccurred(), "Random workload should become ready")

				// Verify workload properties
				annotations, err := workloadHelper.GetWorkloadAnnotations(workloadConfig.Name, workloadConfig.Type)
				Expect(err).NotTo(HaveOccurred(), "Should get annotations for random workload")
				Expect(annotations).NotTo(BeNil(), "Annotations should not be nil for random workload")

				// Verify workload can be deleted
				err = workloadHelper.DeleteWorkload(workloadConfig.Name, workloadConfig.Type)
				Expect(err).NotTo(HaveOccurred(), "Should delete random workload")
			}
		})
	})
})
