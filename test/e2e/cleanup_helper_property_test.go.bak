//go:build e2e
// +build e2e

package e2e

import (
	"context"
	"fmt"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/optipod/optipod/api/v1alpha1"
	"github.com/optipod/optipod/test/e2e/fixtures"
	"github.com/optipod/optipod/test/e2e/helpers"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

var _ = Describe("CleanupHelper Property Tests", func() {
	var (
		cleanupHelper  *helpers.CleanupHelper
		policyHelper   *helpers.PolicyHelper
		workloadHelper *helpers.WorkloadHelper
		generator      *fixtures.TestScenarioGenerator
	)

	BeforeEach(func() {
		cleanupHelper = helpers.NewCleanupHelper(k8sClient)
		policyHelper = helpers.NewPolicyHelper(k8sClient, "optipod-system")
		workloadHelper = helpers.NewWorkloadHelper(k8sClient, "test-cleanup")
		generator = fixtures.NewTestScenarioGenerator()
	})

	Context("Property 19: Test cleanup completeness", func() {
		// **Feature: e2e-test-enhancement, Property 19: Test cleanup completeness**
		// **Validates: Requirements 1.4**

		It("should track and cleanup all resource types completely", func() {
			testNamespace := "test-cleanup-complete"

			// Create test namespace
			namespace := &corev1.Namespace{
				ObjectMeta: metav1.ObjectMeta{
					Name: testNamespace,
					Labels: map[string]string{
						"test": "cleanup-completeness",
					},
				},
			}
			err := k8sClient.Create(context.TODO(), namespace)
			Expect(err).NotTo(HaveOccurred(), "Should create test namespace")
			cleanupHelper.TrackNamespace(testNamespace)

			// Create various resource types to test cleanup
			resourceTypes := []string{"policy", "deployment", "statefulset", "daemonset", "serviceaccount", "clusterrole", "clusterrolebinding"}

			for i, resourceType := range resourceTypes {
				By(fmt.Sprintf("Creating and tracking %s", resourceType))

				switch resourceType {
				case "policy":
					policyConfig, _ := generator.GeneratePolicyModeScenario(v1alpha1.PolicyModeRecommend)
					policyConfig.Name = fmt.Sprintf("cleanup-test-policy-%d", i)

					policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
					Expect(err).NotTo(HaveOccurred(), "Should create policy")
					cleanupHelper.TrackPolicy(policy.Name, policy.Namespace)

				case "deployment":
					workloadConfig := generator.GenerateBasicWorkloadConfig(fmt.Sprintf("cleanup-test-deployment-%d", i), helpers.WorkloadTypeDeployment)
					workloadConfig.Namespace = testNamespace

					deployment, err := workloadHelper.CreateDeployment(workloadConfig)
					Expect(err).NotTo(HaveOccurred(), "Should create deployment")
					cleanupHelper.TrackDeployment(deployment.Name, deployment.Namespace)

				case "statefulset":
					workloadConfig := generator.GenerateBasicWorkloadConfig(fmt.Sprintf("cleanup-test-statefulset-%d", i), helpers.WorkloadTypeStatefulSet)
					workloadConfig.Namespace = testNamespace

					statefulSet, err := workloadHelper.CreateStatefulSet(workloadConfig)
					Expect(err).NotTo(HaveOccurred(), "Should create statefulset")
					cleanupHelper.TrackStatefulSet(statefulSet.Name, statefulSet.Namespace)

				case "daemonset":
					workloadConfig := generator.GenerateBasicWorkloadConfig(fmt.Sprintf("cleanup-test-daemonset-%d", i), helpers.WorkloadTypeDaemonSet)
					workloadConfig.Namespace = testNamespace

					daemonSet, err := workloadHelper.CreateDaemonSet(workloadConfig)
					Expect(err).NotTo(HaveOccurred(), "Should create daemonset")
					cleanupHelper.TrackDaemonSet(daemonSet.Name, daemonSet.Namespace)

				case "serviceaccount":
					serviceAccount := &corev1.ServiceAccount{
						ObjectMeta: metav1.ObjectMeta{
							Name:      fmt.Sprintf("cleanup-test-sa-%d", i),
							Namespace: testNamespace,
						},
					}
					err := k8sClient.Create(context.TODO(), serviceAccount)
					Expect(err).NotTo(HaveOccurred(), "Should create service account")
					cleanupHelper.TrackServiceAccount(serviceAccount.Name, serviceAccount.Namespace)

				case "clusterrole":
					clusterRole := &rbacv1.ClusterRole{
						ObjectMeta: metav1.ObjectMeta{
							Name: fmt.Sprintf("cleanup-test-cr-%d", i),
						},
						Rules: []rbacv1.PolicyRule{
							{
								APIGroups: []string{""},
								Resources: []string{"pods"},
								Verbs:     []string{"get", "list"},
							},
						},
					}
					err := k8sClient.Create(context.TODO(), clusterRole)
					Expect(err).NotTo(HaveOccurred(), "Should create cluster role")
					cleanupHelper.TrackClusterRole(clusterRole.Name)

				case "clusterrolebinding":
					clusterRoleBinding := &rbacv1.ClusterRoleBinding{
						ObjectMeta: metav1.ObjectMeta{
							Name: fmt.Sprintf("cleanup-test-crb-%d", i),
						},
						RoleRef: rbacv1.RoleRef{
							APIGroup: "rbac.authorization.k8s.io",
							Kind:     "ClusterRole",
							Name:     fmt.Sprintf("cleanup-test-cr-%d", i),
						},
						Subjects: []rbacv1.Subject{
							{
								Kind:      "ServiceAccount",
								Name:      fmt.Sprintf("cleanup-test-sa-%d", i),
								Namespace: testNamespace,
							},
						},
					}
					err := k8sClient.Create(context.TODO(), clusterRoleBinding)
					Expect(err).NotTo(HaveOccurred(), "Should create cluster role binding")
					cleanupHelper.TrackClusterRoleBinding(clusterRoleBinding.Name)
				}
			}

			// Verify all resources are tracked
			trackedResources := cleanupHelper.GetTrackedResources()
			Expect(len(trackedResources)).To(Equal(len(resourceTypes)+1), "Should track all resources plus namespace") // +1 for namespace

			// Perform cleanup
			err = cleanupHelper.CleanupAll()
			Expect(err).NotTo(HaveOccurred(), "Cleanup should complete without errors")

			// Verify cleanup completeness
			err = cleanupHelper.ValidateCleanupCompleteness()
			Expect(err).NotTo(HaveOccurred(), "All resources should be cleaned up")

			// Double-check by manually verifying some resources are gone
			Eventually(func() bool {
				ns := &corev1.Namespace{}
				err := k8sClient.Get(context.TODO(), types.NamespacedName{Name: testNamespace}, ns)
				return errors.IsNotFound(err)
			}, 2*time.Minute, 5*time.Second).Should(BeTrue(), "Namespace should be deleted")
		})

		It("should handle cleanup failures gracefully", func() {
			testNamespace := "test-cleanup-failure"

			// Create test namespace
			namespace := &corev1.Namespace{
				ObjectMeta: metav1.ObjectMeta{
					Name: testNamespace,
				},
			}
			err := k8sClient.Create(context.TODO(), namespace)
			Expect(err).NotTo(HaveOccurred(), "Should create test namespace")
			cleanupHelper.TrackNamespace(testNamespace)

			// Create a resource that will be deleted manually to simulate cleanup failure
			deployment := &appsv1.Deployment{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "test-deployment",
					Namespace: testNamespace,
				},
				Spec: appsv1.DeploymentSpec{
					Replicas: &[]int32{1}[0],
					Selector: &metav1.LabelSelector{
						MatchLabels: map[string]string{"app": "test"},
					},
					Template: corev1.PodTemplateSpec{
						ObjectMeta: metav1.ObjectMeta{
							Labels: map[string]string{"app": "test"},
						},
						Spec: corev1.PodSpec{
							Containers: []corev1.Container{
								{
									Name:  "test",
									Image: "nginx:1.25-alpine",
								},
							},
						},
					},
				},
			}
			err = k8sClient.Create(context.TODO(), deployment)
			Expect(err).NotTo(HaveOccurred(), "Should create deployment")
			cleanupHelper.TrackDeployment(deployment.Name, deployment.Namespace)

			// Manually delete the deployment to simulate a resource that's already gone
			err = k8sClient.Delete(context.TODO(), deployment)
			Expect(err).NotTo(HaveOccurred(), "Should manually delete deployment")

			// Wait for deletion to complete
			Eventually(func() bool {
				dep := &appsv1.Deployment{}
				err := k8sClient.Get(context.TODO(), types.NamespacedName{
					Name:      deployment.Name,
					Namespace: deployment.Namespace,
				}, dep)
				return errors.IsNotFound(err)
			}, 1*time.Minute, 5*time.Second).Should(BeTrue(), "Deployment should be deleted")

			// Cleanup should still succeed even though one resource is already gone
			err = cleanupHelper.CleanupAll()
			Expect(err).NotTo(HaveOccurred(), "Cleanup should handle missing resources gracefully")
		})

		It("should support force cleanup for stuck resources", func() {
			testNamespace := "test-force-cleanup"

			// Create test namespace
			namespace := &corev1.Namespace{
				ObjectMeta: metav1.ObjectMeta{
					Name: testNamespace,
				},
			}
			err := k8sClient.Create(context.TODO(), namespace)
			Expect(err).NotTo(HaveOccurred(), "Should create test namespace")
			cleanupHelper.TrackNamespace(testNamespace)

			// Create a deployment
			deployment := &appsv1.Deployment{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "force-cleanup-test",
					Namespace: testNamespace,
				},
				Spec: appsv1.DeploymentSpec{
					Replicas: &[]int32{1}[0],
					Selector: &metav1.LabelSelector{
						MatchLabels: map[string]string{"app": "force-test"},
					},
					Template: corev1.PodTemplateSpec{
						ObjectMeta: metav1.ObjectMeta{
							Labels: map[string]string{"app": "force-test"},
						},
						Spec: corev1.PodSpec{
							Containers: []corev1.Container{
								{
									Name:  "test",
									Image: "nginx:1.25-alpine",
								},
							},
						},
					},
				},
			}
			err = k8sClient.Create(context.TODO(), deployment)
			Expect(err).NotTo(HaveOccurred(), "Should create deployment")
			cleanupHelper.TrackDeployment(deployment.Name, deployment.Namespace)

			// Test force cleanup
			err = cleanupHelper.ForceCleanupAll()
			Expect(err).NotTo(HaveOccurred(), "Force cleanup should succeed")

			// Verify resources are cleaned up
			Eventually(func() bool {
				ns := &corev1.Namespace{}
				err := k8sClient.Get(context.TODO(), types.NamespacedName{Name: testNamespace}, ns)
				return errors.IsNotFound(err)
			}, 2*time.Minute, 5*time.Second).Should(BeTrue(), "Namespace should be force deleted")
		})

		It("should handle namespace-based cleanup correctly", func() {
			testNamespace := "test-namespace-cleanup"

			// Create test namespace
			namespace := &corev1.Namespace{
				ObjectMeta: metav1.ObjectMeta{
					Name: testNamespace,
					Labels: map[string]string{
						"test": "namespace-cleanup",
					},
				},
			}
			err := k8sClient.Create(context.TODO(), namespace)
			Expect(err).NotTo(HaveOccurred(), "Should create test namespace")

			// Create multiple resources in the namespace
			for i := 0; i < 3; i++ {
				// Create deployment
				deployment := &appsv1.Deployment{
					ObjectMeta: metav1.ObjectMeta{
						Name:      fmt.Sprintf("ns-cleanup-deployment-%d", i),
						Namespace: testNamespace,
					},
					Spec: appsv1.DeploymentSpec{
						Replicas: &[]int32{1}[0],
						Selector: &metav1.LabelSelector{
							MatchLabels: map[string]string{"app": fmt.Sprintf("test-%d", i)},
						},
						Template: corev1.PodTemplateSpec{
							ObjectMeta: metav1.ObjectMeta{
								Labels: map[string]string{"app": fmt.Sprintf("test-%d", i)},
							},
							Spec: corev1.PodSpec{
								Containers: []corev1.Container{
									{
										Name:  "test",
										Image: "nginx:1.25-alpine",
									},
								},
							},
						},
					},
				}
				err = k8sClient.Create(context.TODO(), deployment)
				Expect(err).NotTo(HaveOccurred(), "Should create deployment")

				// Create service account
				serviceAccount := &corev1.ServiceAccount{
					ObjectMeta: metav1.ObjectMeta{
						Name:      fmt.Sprintf("ns-cleanup-sa-%d", i),
						Namespace: testNamespace,
					},
				}
				err = k8sClient.Create(context.TODO(), serviceAccount)
				Expect(err).NotTo(HaveOccurred(), "Should create service account")
			}

			// Perform namespace cleanup
			err = cleanupHelper.CleanupNamespace(testNamespace)
			Expect(err).NotTo(HaveOccurred(), "Namespace cleanup should succeed")

			// Verify all resources in namespace are cleaned up
			Eventually(func() int {
				deployments := &appsv1.DeploymentList{}
				err := k8sClient.List(context.TODO(), deployments, &client.ListOptions{Namespace: testNamespace})
				if err != nil {
					return -1
				}
				return len(deployments.Items)
			}, 2*time.Minute, 5*time.Second).Should(Equal(0), "All deployments should be cleaned up")

			Eventually(func() int {
				serviceAccounts := &corev1.ServiceAccountList{}
				err := k8sClient.List(context.TODO(), serviceAccounts, &client.ListOptions{Namespace: testNamespace})
				if err != nil {
					return -1
				}
				// Filter out default service account
				count := 0
				for _, sa := range serviceAccounts.Items {
					if sa.Name != "default" {
						count++
					}
				}
				return count
			}, 2*time.Minute, 5*time.Second).Should(Equal(0), "All custom service accounts should be cleaned up")

			// Clean up the namespace itself
			err = k8sClient.Delete(context.TODO(), namespace)
			Expect(err).NotTo(HaveOccurred(), "Should delete namespace")
		})

		It("should maintain resource tracking state correctly", func() {
			// Test resource tracking operations
			initialCount := len(cleanupHelper.GetTrackedResources())

			// Track various resources
			cleanupHelper.TrackPolicy("test-policy", "optipod-system")
			cleanupHelper.TrackDeployment("test-deployment", "default")
			cleanupHelper.TrackServiceAccount("test-sa", "default")

			// Verify tracking
			trackedResources := cleanupHelper.GetTrackedResources()
			Expect(len(trackedResources)).To(Equal(initialCount+3), "Should track 3 additional resources")

			// Verify resource details
			policyFound := false
			deploymentFound := false
			saFound := false

			for _, resource := range trackedResources {
				switch {
				case resource.Name == "test-policy" && resource.Kind == "OptimizationPolicy":
					policyFound = true
				case resource.Name == "test-deployment" && resource.Kind == "Deployment":
					deploymentFound = true
				case resource.Name == "test-sa" && resource.Kind == "ServiceAccount":
					saFound = true
				}
			}

			Expect(policyFound).To(BeTrue(), "Policy should be tracked")
			Expect(deploymentFound).To(BeTrue(), "Deployment should be tracked")
			Expect(saFound).To(BeTrue(), "ServiceAccount should be tracked")

			// Clear tracking
			cleanupHelper.ClearTrackedResources()
			clearedResources := cleanupHelper.GetTrackedResources()
			Expect(len(clearedResources)).To(Equal(0), "All tracked resources should be cleared")
		})
	})
})
