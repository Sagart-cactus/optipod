//go:build e2e
// +build e2e

package e2e

import (
	"context"
	"fmt"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/optipod/optipod/api/v1alpha1"
	"github.com/optipod/optipod/test/e2e/fixtures"
	"github.com/optipod/optipod/test/e2e/helpers"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes/scheme"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/config"
)

var _ = Describe("Resource Bounds Enforcement", Ordered, func() {
	var (
		k8sClient        client.Client
		policyHelper     *helpers.PolicyHelper
		workloadHelper   *helpers.WorkloadHelper
		validationHelper *helpers.ValidationHelper
		cleanupHelper    *helpers.CleanupHelper
		testNamespace    string
		policyNamespace  string
	)

	BeforeAll(func() {
		By("setting up test environment")

		// Initialize Kubernetes client
		cfg, err := config.GetConfig()
		Expect(err).NotTo(HaveOccurred())

		// Add OptipPod scheme
		s := runtime.NewScheme()
		Expect(scheme.AddToScheme(s)).To(Succeed())
		Expect(v1alpha1.AddToScheme(s)).To(Succeed())

		k8sClient, err = client.New(cfg, client.Options{Scheme: s})
		Expect(err).NotTo(HaveOccurred())

		// Set up namespaces
		policyNamespace = "optipod-system"
	})

	AfterAll(func() {
		By("cleaning up test environment")
		// Final cleanup will be handled by individual test cleanup
	})

	BeforeEach(func() {
		testNamespace = fmt.Sprintf("bounds-test-%d", GinkgoRandomSeed())

		// Create test namespace
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNamespace,
				Labels: map[string]string{
					"environment": "test",
					"test-type":   "bounds",
				},
			},
		}
		Expect(k8sClient.Create(context.TODO(), ns)).To(Succeed())

		// Initialize helpers
		policyHelper = helpers.NewPolicyHelper(k8sClient, policyNamespace)
		workloadHelper = helpers.NewWorkloadHelper(k8sClient, testNamespace)
		validationHelper = helpers.NewValidationHelper(k8sClient)
		cleanupHelper = helpers.NewCleanupHelper(k8sClient)

		// Track namespace for cleanup
		cleanupHelper.TrackResource(helpers.ResourceRef{
			Name:      testNamespace,
			Namespace: "",
			Kind:      "Namespace",
		})
	})

	AfterEach(func() {
		// Clean up all test resources
		err := cleanupHelper.CleanupAll()
		if err != nil {
			GinkgoWriter.Printf("Warning: cleanup failed: %v\n", err)
		}
	})

	Context("Within Bounds Scenarios", func() {
		It("should respect configured limits when workload resources are within bounds", func() {
			By("Creating a policy with specific resource bounds")
			policyName := fmt.Sprintf("within-bounds-policy-%d", GinkgoRandomSeed())
			policyConfig := helpers.PolicyConfig{
				Name: policyName,
				Mode: v1alpha1.ModeRecommend,
				NamespaceSelector: map[string]string{
					"environment": "test",
				},
				WorkloadSelector: map[string]string{
					"optimize": "true",
				},
				ResourceBounds: helpers.ResourceBounds{
					CPU: helpers.ResourceBound{
						Min: "200m",
						Max: "1000m",
					},
					Memory: helpers.ResourceBound{
						Min: "256Mi",
						Max: "1Gi",
					},
				},
				MetricsConfig: helpers.MetricsConfig{
					Provider:      "metrics-server",
					RollingWindow: "1h",
					Percentile:    "P90",
					SafetyFactor:  1.2,
				},
				UpdateStrategy: helpers.UpdateStrategy{
					AllowInPlaceResize: true,
					AllowRecreate:      false,
					UpdateRequestsOnly: true,
				},
			}

			policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackResource(helpers.ResourceRef{
				Name:      policy.Name,
				Namespace: policy.Namespace,
				Kind:      "OptimizationPolicy",
			})

			By("Creating a workload with resources within the bounds")
			workloadName := fmt.Sprintf("within-bounds-workload-%d", GinkgoRandomSeed())
			workloadConfig := helpers.WorkloadConfig{
				Name:      workloadName,
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeDeployment,
				Labels: map[string]string{
					"optimize": "true",
					"app":      workloadName,
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "500m",  // Within bounds (200m-1000m)
						Memory: "512Mi", // Within bounds (256Mi-1Gi)
					},
					Limits: helpers.ResourceList{
						CPU:    "800m",
						Memory: "768Mi",
					},
				},
				Replicas: 1,
				Image:    "nginx:1.25-alpine",
			}

			deployment, err := workloadHelper.CreateDeployment(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackResource(helpers.ResourceRef{
				Name:      deployment.Name,
				Namespace: deployment.Namespace,
				Kind:      "Deployment",
			})

			By("Waiting for the workload to be ready")
			err = workloadHelper.WaitForWorkloadReady(workloadConfig.Name, workloadConfig.Type, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("Waiting for the policy to process the workload")
			time.Sleep(30 * time.Second) // Allow time for policy processing

			By("Verifying that recommendations respect the configured bounds")
			annotations, err := workloadHelper.GetWorkloadAnnotations(workloadConfig.Name, workloadConfig.Type)
			Expect(err).NotTo(HaveOccurred())

			// Validate that recommendations are present and within bounds
			err = validationHelper.ValidateResourceBounds(annotations, policyConfig.ResourceBounds)
			Expect(err).NotTo(HaveOccurred())

			// Validate recommendation format
			err = validationHelper.ValidateRecommendations(annotations)
			Expect(err).NotTo(HaveOccurred())
		})

		DescribeTable("should handle various resource units within bounds",
			func(cpuReq, memReq, cpuMin, cpuMax, memMin, memMax string) {
				By("Creating a policy with the specified bounds")
				policyName := fmt.Sprintf("units-policy-%d", GinkgoRandomSeed())
				policyConfig := helpers.PolicyConfig{
					Name: policyName,
					Mode: v1alpha1.ModeRecommend,
					NamespaceSelector: map[string]string{
						"environment": "test",
					},
					WorkloadSelector: map[string]string{
						"optimize": "true",
					},
					ResourceBounds: helpers.ResourceBounds{
						CPU: helpers.ResourceBound{
							Min: cpuMin,
							Max: cpuMax,
						},
						Memory: helpers.ResourceBound{
							Min: memMin,
							Max: memMax,
						},
					},
					MetricsConfig: helpers.MetricsConfig{
						Provider:      "metrics-server",
						RollingWindow: "1h",
						Percentile:    "P90",
						SafetyFactor:  1.2,
					},
					UpdateStrategy: helpers.UpdateStrategy{
						AllowInPlaceResize: true,
						AllowRecreate:      false,
						UpdateRequestsOnly: true,
					},
				}

				policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
				Expect(err).NotTo(HaveOccurred())
				cleanupHelper.TrackResource(helpers.ResourceRef{
					Name:      policy.Name,
					Namespace: policy.Namespace,
					Kind:      "OptimizationPolicy",
				})

				By("Creating a workload with the specified resource units")
				workloadName := fmt.Sprintf("units-workload-%d", GinkgoRandomSeed())
				workloadConfig := helpers.WorkloadConfig{
					Name:      workloadName,
					Namespace: testNamespace,
					Type:      helpers.WorkloadTypeDeployment,
					Labels: map[string]string{
						"optimize": "true",
						"app":      workloadName,
					},
					Resources: helpers.ResourceRequirements{
						Requests: helpers.ResourceList{
							CPU:    cpuReq,
							Memory: memReq,
						},
					},
					Replicas: 1,
					Image:    "nginx:1.25-alpine",
				}

				deployment, err := workloadHelper.CreateDeployment(workloadConfig)
				Expect(err).NotTo(HaveOccurred())
				cleanupHelper.TrackResource(helpers.ResourceRef{
					Name:      deployment.Name,
					Namespace: deployment.Namespace,
					Kind:      "Deployment",
				})

				By("Waiting for the workload to be ready")
				err = workloadHelper.WaitForWorkloadReady(workloadConfig.Name, workloadConfig.Type, 2*time.Minute)
				Expect(err).NotTo(HaveOccurred())

				By("Waiting for the policy to process the workload")
				time.Sleep(30 * time.Second)

				By("Verifying that resource units are handled correctly")
				annotations, err := workloadHelper.GetWorkloadAnnotations(workloadConfig.Name, workloadConfig.Type)
				Expect(err).NotTo(HaveOccurred())

				// Validate that recommendations respect bounds regardless of units
				err = validationHelper.ValidateResourceBounds(annotations, policyConfig.ResourceBounds)
				Expect(err).NotTo(HaveOccurred())

				// Validate resource quantity parsing consistency
				quantities := []string{cpuReq, memReq, cpuMin, cpuMax, memMin, memMax}
				err = validationHelper.ValidateResourceQuantityParsing(quantities)
				Expect(err).NotTo(HaveOccurred())
			},
			Entry("millicores and MiB", "500m", "512Mi", "100m", "1000m", "256Mi", "1Gi"),
			Entry("cores and GiB", "1", "1Gi", "500m", "2", "512Mi", "2Gi"),
			Entry("mixed units", "1500m", "768Mi", "1", "2000m", "512Mi", "1Gi"),
		)
	})

	Context("Below Minimum Clamping Scenarios", func() {
		It("should clamp CPU recommendations to minimum values", func() {
			By("Creating a policy with CPU minimum bounds")
			policyConfig := helpers.PolicyConfig{
				Name: "cpu-min-clamp-policy",
				Mode: v1alpha1.ModeRecommend,
				NamespaceSelector: map[string]string{
					"environment": "test",
				},
				WorkloadSelector: map[string]string{
					"optimize": "true",
				},
				ResourceBounds: helpers.ResourceBounds{
					CPU: helpers.ResourceBound{
						Min: "500m", // Minimum CPU
						Max: "2000m",
					},
					Memory: helpers.ResourceBound{
						Min: "256Mi",
						Max: "2Gi",
					},
				},
				MetricsConfig: helpers.MetricsConfig{
					Provider:      "metrics-server",
					RollingWindow: "1h",
					Percentile:    "P90",
					SafetyFactor:  1.2,
				},
				UpdateStrategy: helpers.UpdateStrategy{
					AllowInPlaceResize: true,
					AllowRecreate:      false,
					UpdateRequestsOnly: true,
				},
			}

			policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackResource(helpers.ResourceRef{
				Name:      policy.Name,
				Namespace: policy.Namespace,
				Kind:      "OptimizationPolicy",
			})

			By("Creating a workload with CPU below minimum")
			workloadConfig := helpers.WorkloadConfig{
				Name:      "cpu-below-min-workload",
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeDeployment,
				Labels: map[string]string{
					"optimize": "true",
					"app":      "cpu-below-min-workload",
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "100m",  // Below minimum (500m)
						Memory: "512Mi", // Within bounds
					},
				},
				Replicas: 1,
				Image:    "nginx:1.25-alpine",
			}

			deployment, err := workloadHelper.CreateDeployment(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackResource(helpers.ResourceRef{
				Name:      deployment.Name,
				Namespace: deployment.Namespace,
				Kind:      "Deployment",
			})

			By("Waiting for the workload to be ready")
			err = workloadHelper.WaitForWorkloadReady(workloadConfig.Name, workloadConfig.Type, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("Waiting for the policy to process the workload")
			time.Sleep(30 * time.Second)

			By("Verifying that CPU recommendation is clamped to minimum")
			annotations, err := workloadHelper.GetWorkloadAnnotations(workloadConfig.Name, workloadConfig.Type)
			Expect(err).NotTo(HaveOccurred())

			// Validate that CPU recommendation is at least the minimum
			cpuRec, exists := annotations["optipod.io/recommendation.app.cpu"]
			Expect(exists).To(BeTrue(), "CPU recommendation should be present")

			err = validationHelper.ValidateBoundsEnforcement(cpuRec, "500m", "2000m", true)
			Expect(err).NotTo(HaveOccurred())
		})

		It("should clamp memory recommendations to minimum values", func() {
			By("Creating a policy with memory minimum bounds")
			policyConfig := helpers.PolicyConfig{
				Name: "memory-min-clamp-policy",
				Mode: v1alpha1.ModeRecommend,
				NamespaceSelector: map[string]string{
					"environment": "test",
				},
				WorkloadSelector: map[string]string{
					"optimize": "true",
				},
				ResourceBounds: helpers.ResourceBounds{
					CPU: helpers.ResourceBound{
						Min: "200m",
						Max: "2000m",
					},
					Memory: helpers.ResourceBound{
						Min: "1Gi", // Minimum memory
						Max: "4Gi",
					},
				},
				MetricsConfig: helpers.MetricsConfig{
					Provider:      "metrics-server",
					RollingWindow: "1h",
					Percentile:    "P90",
					SafetyFactor:  1.2,
				},
				UpdateStrategy: helpers.UpdateStrategy{
					AllowInPlaceResize: true,
					AllowRecreate:      false,
					UpdateRequestsOnly: true,
				},
			}

			policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackResource(helpers.ResourceRef{
				Name:      policy.Name,
				Namespace: policy.Namespace,
				Kind:      "OptimizationPolicy",
			})

			By("Creating a workload with memory below minimum")
			workloadConfig := helpers.WorkloadConfig{
				Name:      "memory-below-min-workload",
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeDeployment,
				Labels: map[string]string{
					"optimize": "true",
					"app":      "memory-below-min-workload",
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "500m",  // Within bounds
						Memory: "256Mi", // Below minimum (1Gi)
					},
				},
				Replicas: 1,
				Image:    "nginx:1.25-alpine",
			}

			deployment, err := workloadHelper.CreateDeployment(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackResource(helpers.ResourceRef{
				Name:      deployment.Name,
				Namespace: deployment.Namespace,
				Kind:      "Deployment",
			})

			By("Waiting for the workload to be ready")
			err = workloadHelper.WaitForWorkloadReady(workloadConfig.Name, workloadConfig.Type, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("Waiting for the policy to process the workload")
			time.Sleep(30 * time.Second)

			By("Verifying that memory recommendation is clamped to minimum")
			annotations, err := workloadHelper.GetWorkloadAnnotations(workloadConfig.Name, workloadConfig.Type)
			Expect(err).NotTo(HaveOccurred())

			// Validate that memory recommendation is at least the minimum
			memRec, exists := annotations["optipod.io/recommendation.app.memory"]
			Expect(exists).To(BeTrue(), "Memory recommendation should be present")

			err = validationHelper.ValidateBoundsEnforcement(memRec, "1Gi", "4Gi", true)
			Expect(err).NotTo(HaveOccurred())
		})

		DescribeTable("should clamp resources below minimum bounds",
			func(testCase fixtures.BoundsTestCase) {
				By("Creating a policy with the specified bounds")
				policyName := fmt.Sprintf("clamp-min-policy-%s", testCase.Name)
				policyConfig := helpers.PolicyConfig{
					Name: policyName,
					Mode: v1alpha1.ModeRecommend,
					NamespaceSelector: map[string]string{
						"environment": "test",
					},
					WorkloadSelector: map[string]string{
						"optimize": "true",
					},
					ResourceBounds: testCase.PolicyBounds,
					MetricsConfig: helpers.MetricsConfig{
						Provider:      "metrics-server",
						RollingWindow: "1h",
						Percentile:    "P90",
						SafetyFactor:  1.2,
					},
					UpdateStrategy: helpers.UpdateStrategy{
						AllowInPlaceResize: true,
						AllowRecreate:      false,
						UpdateRequestsOnly: true,
					},
				}

				policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
				Expect(err).NotTo(HaveOccurred())
				cleanupHelper.TrackResource(helpers.ResourceRef{
					Name:      policy.Name,
					Namespace: policy.Namespace,
					Kind:      "OptimizationPolicy",
				})

				By("Creating a workload with resources below minimum")
				workloadName := fmt.Sprintf("clamp-min-workload-%s", testCase.Name)
				workloadConfig := helpers.WorkloadConfig{
					Name:      workloadName,
					Namespace: testNamespace,
					Type:      helpers.WorkloadTypeDeployment,
					Labels: map[string]string{
						"optimize": "true",
						"app":      workloadName,
					},
					Resources: testCase.WorkloadResources,
					Replicas:  1,
					Image:     "nginx:1.25-alpine",
				}

				deployment, err := workloadHelper.CreateDeployment(workloadConfig)
				Expect(err).NotTo(HaveOccurred())
				cleanupHelper.TrackResource(helpers.ResourceRef{
					Name:      deployment.Name,
					Namespace: deployment.Namespace,
					Kind:      "Deployment",
				})

				By("Waiting for the workload to be ready")
				err = workloadHelper.WaitForWorkloadReady(workloadConfig.Name, workloadConfig.Type, 2*time.Minute)
				Expect(err).NotTo(HaveOccurred())

				By("Waiting for the policy to process the workload")
				time.Sleep(30 * time.Second)

				By("Verifying that recommendations are clamped to minimum values")
				annotations, err := workloadHelper.GetWorkloadAnnotations(workloadConfig.Name, workloadConfig.Type)
				Expect(err).NotTo(HaveOccurred())

				// Validate that recommendations respect minimum bounds
				err = validationHelper.ValidateResourceBounds(annotations, testCase.PolicyBounds)
				Expect(err).NotTo(HaveOccurred())

				// Validate specific clamping behavior based on expected behavior
				if testCase.ExpectedBehavior == fixtures.BoundsClampedMin {
					if cpuRec, exists := annotations["optipod.io/recommendation.app.cpu"]; exists {
						err = validationHelper.ValidateBoundsEnforcement(cpuRec, testCase.PolicyBounds.CPU.Min, testCase.PolicyBounds.CPU.Max, true)
						Expect(err).NotTo(HaveOccurred())
					}
					if memRec, exists := annotations["optipod.io/recommendation.app.memory"]; exists {
						err = validationHelper.ValidateBoundsEnforcement(memRec, testCase.PolicyBounds.Memory.Min, testCase.PolicyBounds.Memory.Max, true)
						Expect(err).NotTo(HaveOccurred())
					}
				}
			},
			Entry("CPU below minimum", fixtures.BoundsTestCase{
				Name: "cpu-below-min",
				PolicyBounds: helpers.ResourceBounds{
					CPU:    helpers.ResourceBound{Min: "500m", Max: "2000m"},
					Memory: helpers.ResourceBound{Min: "256Mi", Max: "2Gi"},
				},
				WorkloadResources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{CPU: "100m", Memory: "512Mi"},
				},
				ExpectedBehavior: fixtures.BoundsClampedMin,
			}),
			Entry("Memory below minimum", fixtures.BoundsTestCase{
				Name: "memory-below-min",
				PolicyBounds: helpers.ResourceBounds{
					CPU:    helpers.ResourceBound{Min: "200m", Max: "2000m"},
					Memory: helpers.ResourceBound{Min: "1Gi", Max: "4Gi"},
				},
				WorkloadResources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{CPU: "500m", Memory: "256Mi"},
				},
				ExpectedBehavior: fixtures.BoundsClampedMin,
			}),
		)
	})

	Context("Above Maximum Clamping Scenarios", func() {
		It("should clamp CPU recommendations to maximum values", func() {
			By("Creating a policy with CPU maximum bounds")
			policyConfig := helpers.PolicyConfig{
				Name: "cpu-max-clamp-policy",
				Mode: v1alpha1.ModeRecommend,
				NamespaceSelector: map[string]string{
					"environment": "test",
				},
				WorkloadSelector: map[string]string{
					"optimize": "true",
				},
				ResourceBounds: helpers.ResourceBounds{
					CPU: helpers.ResourceBound{
						Min: "100m",
						Max: "500m", // Maximum CPU
					},
					Memory: helpers.ResourceBound{
						Min: "128Mi",
						Max: "2Gi",
					},
				},
				MetricsConfig: helpers.MetricsConfig{
					Provider:      "metrics-server",
					RollingWindow: "1h",
					Percentile:    "P90",
					SafetyFactor:  1.2,
				},
				UpdateStrategy: helpers.UpdateStrategy{
					AllowInPlaceResize: true,
					AllowRecreate:      false,
					UpdateRequestsOnly: true,
				},
			}

			policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackResource(helpers.ResourceRef{
				Name:      policy.Name,
				Namespace: policy.Namespace,
				Kind:      "OptimizationPolicy",
			})

			By("Creating a workload with CPU above maximum")
			workloadConfig := helpers.WorkloadConfig{
				Name:      "cpu-above-max-workload",
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeDeployment,
				Labels: map[string]string{
					"optimize": "true",
					"app":      "cpu-above-max-workload",
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "2000m", // Above maximum (500m)
						Memory: "512Mi", // Within bounds
					},
				},
				Replicas: 1,
				Image:    "nginx:1.25-alpine",
			}

			deployment, err := workloadHelper.CreateDeployment(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackResource(helpers.ResourceRef{
				Name:      deployment.Name,
				Namespace: deployment.Namespace,
				Kind:      "Deployment",
			})

			By("Waiting for the workload to be ready")
			err = workloadHelper.WaitForWorkloadReady(workloadConfig.Name, workloadConfig.Type, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("Waiting for the policy to process the workload")
			time.Sleep(30 * time.Second)

			By("Verifying that CPU recommendation is clamped to maximum")
			annotations, err := workloadHelper.GetWorkloadAnnotations(workloadConfig.Name, workloadConfig.Type)
			Expect(err).NotTo(HaveOccurred())

			// Validate that CPU recommendation is at most the maximum
			cpuRec, exists := annotations["optipod.io/recommendation.app.cpu"]
			Expect(exists).To(BeTrue(), "CPU recommendation should be present")

			err = validationHelper.ValidateBoundsEnforcement(cpuRec, "100m", "500m", true)
			Expect(err).NotTo(HaveOccurred())
		})

		It("should clamp memory recommendations to maximum values", func() {
			By("Creating a policy with memory maximum bounds")
			policyConfig := helpers.PolicyConfig{
				Name: "memory-max-clamp-policy",
				Mode: v1alpha1.ModeRecommend,
				NamespaceSelector: map[string]string{
					"environment": "test",
				},
				WorkloadSelector: map[string]string{
					"optimize": "true",
				},
				ResourceBounds: helpers.ResourceBounds{
					CPU: helpers.ResourceBound{
						Min: "100m",
						Max: "2000m",
					},
					Memory: helpers.ResourceBound{
						Min: "128Mi",
						Max: "512Mi", // Maximum memory
					},
				},
				MetricsConfig: helpers.MetricsConfig{
					Provider:      "metrics-server",
					RollingWindow: "1h",
					Percentile:    "P90",
					SafetyFactor:  1.2,
				},
				UpdateStrategy: helpers.UpdateStrategy{
					AllowInPlaceResize: true,
					AllowRecreate:      false,
					UpdateRequestsOnly: true,
				},
			}

			policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackResource(helpers.ResourceRef{
				Name:      policy.Name,
				Namespace: policy.Namespace,
				Kind:      "OptimizationPolicy",
			})

			By("Creating a workload with memory above maximum")
			workloadConfig := helpers.WorkloadConfig{
				Name:      "memory-above-max-workload",
				Namespace: testNamespace,
				Type:      helpers.WorkloadTypeDeployment,
				Labels: map[string]string{
					"optimize": "true",
					"app":      "memory-above-max-workload",
				},
				Resources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{
						CPU:    "500m", // Within bounds
						Memory: "2Gi",  // Above maximum (512Mi)
					},
				},
				Replicas: 1,
				Image:    "nginx:1.25-alpine",
			}

			deployment, err := workloadHelper.CreateDeployment(workloadConfig)
			Expect(err).NotTo(HaveOccurred())
			cleanupHelper.TrackResource(helpers.ResourceRef{
				Name:      deployment.Name,
				Namespace: deployment.Namespace,
				Kind:      "Deployment",
			})

			By("Waiting for the workload to be ready")
			err = workloadHelper.WaitForWorkloadReady(workloadConfig.Name, workloadConfig.Type, 2*time.Minute)
			Expect(err).NotTo(HaveOccurred())

			By("Waiting for the policy to process the workload")
			time.Sleep(30 * time.Second)

			By("Verifying that memory recommendation is clamped to maximum")
			annotations, err := workloadHelper.GetWorkloadAnnotations(workloadConfig.Name, workloadConfig.Type)
			Expect(err).NotTo(HaveOccurred())

			// Validate that memory recommendation is at most the maximum
			memRec, exists := annotations["optipod.io/recommendation.app.memory"]
			Expect(exists).To(BeTrue(), "Memory recommendation should be present")

			err = validationHelper.ValidateBoundsEnforcement(memRec, "128Mi", "512Mi", true)
			Expect(err).NotTo(HaveOccurred())
		})

		DescribeTable("should clamp resources above maximum bounds",
			func(testCase fixtures.BoundsTestCase) {
				By("Creating a policy with the specified bounds")
				policyName := fmt.Sprintf("clamp-max-policy-%s", testCase.Name)
				policyConfig := helpers.PolicyConfig{
					Name: policyName,
					Mode: v1alpha1.ModeRecommend,
					NamespaceSelector: map[string]string{
						"environment": "test",
					},
					WorkloadSelector: map[string]string{
						"optimize": "true",
					},
					ResourceBounds: testCase.PolicyBounds,
					MetricsConfig: helpers.MetricsConfig{
						Provider:      "metrics-server",
						RollingWindow: "1h",
						Percentile:    "P90",
						SafetyFactor:  1.2,
					},
					UpdateStrategy: helpers.UpdateStrategy{
						AllowInPlaceResize: true,
						AllowRecreate:      false,
						UpdateRequestsOnly: true,
					},
				}

				policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
				Expect(err).NotTo(HaveOccurred())
				cleanupHelper.TrackResource(helpers.ResourceRef{
					Name:      policy.Name,
					Namespace: policy.Namespace,
					Kind:      "OptimizationPolicy",
				})

				By("Creating a workload with resources above maximum")
				workloadName := fmt.Sprintf("clamp-max-workload-%s", testCase.Name)
				workloadConfig := helpers.WorkloadConfig{
					Name:      workloadName,
					Namespace: testNamespace,
					Type:      helpers.WorkloadTypeDeployment,
					Labels: map[string]string{
						"optimize": "true",
						"app":      workloadName,
					},
					Resources: testCase.WorkloadResources,
					Replicas:  1,
					Image:     "nginx:1.25-alpine",
				}

				deployment, err := workloadHelper.CreateDeployment(workloadConfig)
				Expect(err).NotTo(HaveOccurred())
				cleanupHelper.TrackResource(helpers.ResourceRef{
					Name:      deployment.Name,
					Namespace: deployment.Namespace,
					Kind:      "Deployment",
				})

				By("Waiting for the workload to be ready")
				err = workloadHelper.WaitForWorkloadReady(workloadConfig.Name, workloadConfig.Type, 2*time.Minute)
				Expect(err).NotTo(HaveOccurred())

				By("Waiting for the policy to process the workload")
				time.Sleep(30 * time.Second)

				By("Verifying that recommendations are clamped to maximum values")
				annotations, err := workloadHelper.GetWorkloadAnnotations(workloadConfig.Name, workloadConfig.Type)
				Expect(err).NotTo(HaveOccurred())

				// Validate that recommendations respect maximum bounds
				err = validationHelper.ValidateResourceBounds(annotations, testCase.PolicyBounds)
				Expect(err).NotTo(HaveOccurred())

				// Validate specific clamping behavior based on expected behavior
				if testCase.ExpectedBehavior == fixtures.BoundsClampedMax {
					if cpuRec, exists := annotations["optipod.io/recommendation.app.cpu"]; exists {
						err = validationHelper.ValidateBoundsEnforcement(cpuRec, testCase.PolicyBounds.CPU.Min, testCase.PolicyBounds.CPU.Max, true)
						Expect(err).NotTo(HaveOccurred())
					}
					if memRec, exists := annotations["optipod.io/recommendation.app.memory"]; exists {
						err = validationHelper.ValidateBoundsEnforcement(memRec, testCase.PolicyBounds.Memory.Min, testCase.PolicyBounds.Memory.Max, true)
						Expect(err).NotTo(HaveOccurred())
					}
				}
			},
			Entry("CPU above maximum", fixtures.BoundsTestCase{
				Name: "cpu-above-max",
				PolicyBounds: helpers.ResourceBounds{
					CPU:    helpers.ResourceBound{Min: "100m", Max: "500m"},
					Memory: helpers.ResourceBound{Min: "128Mi", Max: "2Gi"},
				},
				WorkloadResources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{CPU: "2000m", Memory: "512Mi"},
				},
				ExpectedBehavior: fixtures.BoundsClampedMax,
			}),
			Entry("Memory above maximum", fixtures.BoundsTestCase{
				Name: "memory-above-max",
				PolicyBounds: helpers.ResourceBounds{
					CPU:    helpers.ResourceBound{Min: "100m", Max: "2000m"},
					Memory: helpers.ResourceBound{Min: "128Mi", Max: "512Mi"},
				},
				WorkloadResources: helpers.ResourceRequirements{
					Requests: helpers.ResourceList{CPU: "500m", Memory: "2Gi"},
				},
				ExpectedBehavior: fixtures.BoundsClampedMax,
			}),
		)
	})

	Context("Property-Based Testing", func() {
		It("should enforce resource bounds consistently across all configurations", func() {
			// **Feature: e2e-test-enhancement, Property 2: Resource bounds enforcement**
			By("Generating multiple random bounds test cases")
			generator := fixtures.NewBoundsTestCaseGenerator()
			testCases := generator.GenerateRandomBoundsTestCases(10)

			for i, testCase := range testCases {
				By(fmt.Sprintf("Testing case %d: %s", i+1, testCase.Name))

				// Create policy with bounds
				policyName := fmt.Sprintf("property-policy-%d", i)
				policyConfig := helpers.PolicyConfig{
					Name: policyName,
					Mode: v1alpha1.ModeRecommend,
					NamespaceSelector: map[string]string{
						"environment": "test",
					},
					WorkloadSelector: map[string]string{
						"optimize": "true",
					},
					ResourceBounds: testCase.PolicyBounds,
					MetricsConfig: helpers.MetricsConfig{
						Provider:      "metrics-server",
						RollingWindow: "1h",
						Percentile:    "P90",
						SafetyFactor:  1.2,
					},
					UpdateStrategy: helpers.UpdateStrategy{
						AllowInPlaceResize: true,
						AllowRecreate:      false,
						UpdateRequestsOnly: true,
					},
				}

				policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
				Expect(err).NotTo(HaveOccurred())
				cleanupHelper.TrackResource(helpers.ResourceRef{
					Name:      policy.Name,
					Namespace: policy.Namespace,
					Kind:      "OptimizationPolicy",
				})

				// Create workload with test case resources
				workloadName := fmt.Sprintf("property-workload-%d", i)
				workloadConfig := helpers.WorkloadConfig{
					Name:      workloadName,
					Namespace: testNamespace,
					Type:      helpers.WorkloadTypeDeployment,
					Labels: map[string]string{
						"optimize": "true",
						"app":      workloadName,
					},
					Resources: testCase.WorkloadResources,
					Replicas:  1,
					Image:     "nginx:1.25-alpine",
				}

				deployment, err := workloadHelper.CreateDeployment(workloadConfig)
				Expect(err).NotTo(HaveOccurred())
				cleanupHelper.TrackResource(helpers.ResourceRef{
					Name:      deployment.Name,
					Namespace: deployment.Namespace,
					Kind:      "Deployment",
				})

				// Wait for workload to be ready
				err = workloadHelper.WaitForWorkloadReady(workloadConfig.Name, workloadConfig.Type, 2*time.Minute)
				Expect(err).NotTo(HaveOccurred())

				// Wait for policy processing
				time.Sleep(15 * time.Second)

				// Validate bounds enforcement
				annotations, err := workloadHelper.GetWorkloadAnnotations(workloadConfig.Name, workloadConfig.Type)
				Expect(err).NotTo(HaveOccurred())

				// Universal property: recommendations should always respect bounds
				err = validationHelper.ValidateResourceBounds(annotations, testCase.PolicyBounds)
				Expect(err).NotTo(HaveOccurred())

				// Clean up resources for this iteration to avoid conflicts
				err = workloadHelper.DeleteWorkload(workloadConfig.Name, workloadConfig.Type)
				Expect(err).NotTo(HaveOccurred())
				err = policyHelper.DeletePolicy(policyName)
				Expect(err).NotTo(HaveOccurred())

				// Small delay between iterations
				time.Sleep(5 * time.Second)
			}
		})

		It("should parse resource quantities consistently across different units", func() {
			// **Feature: e2e-test-enhancement, Property 3: Resource quantity parsing consistency**
			By("Testing resource quantity parsing with various units")

			testQuantities := [][]string{
				{"100m", "0.1", "100000u"},              // CPU equivalents
				{"1000m", "1", "1000000u"},              // CPU equivalents
				{"128Mi", "134217728", "128*1024*1024"}, // Memory equivalents (conceptual)
				{"1Gi", "1073741824", "1024Mi"},         // Memory equivalents
				{"2", "2000m", "2000000u"},              // CPU equivalents
			}

			for _, quantities := range testQuantities {
				By(fmt.Sprintf("Validating parsing consistency for: %v", quantities))
				err := validationHelper.ValidateResourceQuantityParsing(quantities)
				Expect(err).NotTo(HaveOccurred())
			}
		})
	})
})
