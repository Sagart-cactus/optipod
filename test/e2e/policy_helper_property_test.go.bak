//go:build e2e
// +build e2e

package e2e

import (
	"context"
	"fmt"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/optipod/optipod/api/v1alpha1"
	"github.com/optipod/optipod/test/e2e/fixtures"
	"github.com/optipod/optipod/test/e2e/helpers"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

var _ = Describe("PolicyHelper Property Tests", func() {
	var (
		policyHelper  *helpers.PolicyHelper
		cleanupHelper *helpers.CleanupHelper
		testNamespace string
		generator     *fixtures.TestScenarioGenerator
	)

	BeforeEach(func() {
		testNamespace = "optipod-system"
		policyHelper = helpers.NewPolicyHelper(k8sClient, testNamespace)
		cleanupHelper = helpers.NewCleanupHelper(k8sClient)
		generator = fixtures.NewTestScenarioGenerator()
	})

	AfterEach(func() {
		err := cleanupHelper.CleanupAll()
		Expect(err).NotTo(HaveOccurred(), "Failed to cleanup test resources")
	})

	Context("Property 1: Policy mode behavior consistency", func() {
		// **Feature: e2e-test-enhancement, Property 1: Policy mode behavior consistency**
		// **Validates: Requirements 1.1, 1.2, 1.3**

		DescribeTable("Policy mode behavior should be consistent across all workload types",
			func(mode v1alpha1.PolicyMode) {
				By(fmt.Sprintf("Testing policy mode: %s", mode))

				// Generate policy configuration for the mode
				policyConfig, _ := generator.GeneratePolicyModeScenario(mode)
				policyConfig.Name = fmt.Sprintf("property-test-policy-%s", toLowerCase(string(mode)))

				// Create the policy
				policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
				Expect(err).NotTo(HaveOccurred(), "Failed to create policy")
				cleanupHelper.TrackPolicy(policy.Name, policy.Namespace)

				// Wait for policy to be ready
				err = policyHelper.WaitForPolicyReady(policy.Name, 2*time.Minute)
				Expect(err).NotTo(HaveOccurred(), "Policy should become ready")

				// Validate policy behavior matches the expected mode
				err = policyHelper.ValidatePolicyBehavior(policy.Name, mode)
				Expect(err).NotTo(HaveOccurred(), "Policy behavior should match expected mode")

				// Verify policy spec matches configuration
				retrievedPolicy, err := policyHelper.GetPolicy(policy.Name)
				Expect(err).NotTo(HaveOccurred(), "Should be able to retrieve policy")
				Expect(retrievedPolicy.Spec.Mode).To(Equal(mode), "Policy mode should match")

				// Verify policy status reflects the mode
				Eventually(func() bool {
					updatedPolicy, err := policyHelper.GetPolicy(policy.Name)
					if err != nil {
						return false
					}

					// Check Ready condition
					for _, condition := range updatedPolicy.Status.Conditions {
						if condition.Type == "Ready" && condition.Status == metav1.ConditionTrue {
							return true
						}
					}
					return false
				}, 3*time.Minute, 10*time.Second).Should(BeTrue(), "Policy should have Ready condition")
			},
			Entry("Auto mode", v1alpha1.PolicyModeAuto),
			Entry("Recommend mode", v1alpha1.PolicyModeRecommend),
			Entry("Disabled mode", v1alpha1.PolicyModeDisabled),
		)

		It("should maintain mode consistency across policy lifecycle operations", func() {
			modes := []v1alpha1.PolicyMode{
				v1alpha1.PolicyModeAuto,
				v1alpha1.PolicyModeRecommend,
				v1alpha1.PolicyModeDisabled,
			}

			for i, mode := range modes {
				By(fmt.Sprintf("Testing lifecycle for mode: %s", mode))

				policyName := fmt.Sprintf("lifecycle-test-policy-%d", i)
				policyConfig, _ := generator.GeneratePolicyModeScenario(mode)
				policyConfig.Name = policyName

				// Create policy
				policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
				Expect(err).NotTo(HaveOccurred(), "Failed to create policy")
				cleanupHelper.TrackPolicy(policy.Name, policy.Namespace)

				// Verify initial mode
				Expect(policy.Spec.Mode).To(Equal(mode), "Initial mode should match")

				// Wait for ready state
				err = policyHelper.WaitForPolicyReady(policy.Name, 2*time.Minute)
				Expect(err).NotTo(HaveOccurred(), "Policy should become ready")

				// Validate behavior consistency
				err = policyHelper.ValidatePolicyBehavior(policy.Name, mode)
				Expect(err).NotTo(HaveOccurred(), "Behavior should be consistent")

				// Update policy (simulate configuration change)
				retrievedPolicy, err := policyHelper.GetPolicy(policy.Name)
				Expect(err).NotTo(HaveOccurred(), "Should retrieve policy")

				// Update reconciliation interval
				retrievedPolicy.Spec.ReconciliationInterval = &metav1.Duration{Duration: 2 * time.Minute}
				err = k8sClient.Update(context.TODO(), retrievedPolicy)
				Expect(err).NotTo(HaveOccurred(), "Should update policy")

				// Verify mode remains consistent after update
				Eventually(func() v1alpha1.PolicyMode {
					updatedPolicy, err := policyHelper.GetPolicy(policy.Name)
					if err != nil {
						return ""
					}
					return updatedPolicy.Spec.Mode
				}, 1*time.Minute, 5*time.Second).Should(Equal(mode), "Mode should remain consistent after update")

				// Clean up this policy before next iteration
				err = policyHelper.DeletePolicy(policy.Name)
				Expect(err).NotTo(HaveOccurred(), "Should delete policy")
			}
		})

		It("should handle multiple policies with different modes consistently", func() {
			var policies []*v1alpha1.OptimizationPolicy
			modes := []v1alpha1.PolicyMode{
				v1alpha1.PolicyModeAuto,
				v1alpha1.PolicyModeRecommend,
				v1alpha1.PolicyModeDisabled,
			}

			// Create multiple policies with different modes
			for i, mode := range modes {
				policyName := fmt.Sprintf("multi-policy-test-%d", i)
				policyConfig, _ := generator.GeneratePolicyModeScenario(mode)
				policyConfig.Name = policyName

				// Use different selectors to avoid conflicts
				policyConfig.WorkloadSelector = map[string]string{
					"optimize": "true",
					"test-id":  fmt.Sprintf("test-%d", i),
				}

				policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
				Expect(err).NotTo(HaveOccurred(), "Failed to create policy")
				cleanupHelper.TrackPolicy(policy.Name, policy.Namespace)
				policies = append(policies, policy)
			}

			// Wait for all policies to be ready
			for _, policy := range policies {
				err := policyHelper.WaitForPolicyReady(policy.Name, 2*time.Minute)
				Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Policy %s should become ready", policy.Name))
			}

			// Validate each policy maintains its mode behavior
			for i, policy := range policies {
				expectedMode := modes[i]
				err := policyHelper.ValidatePolicyBehavior(policy.Name, expectedMode)
				Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Policy %s should maintain mode %s", policy.Name, expectedMode))

				// Verify policy isolation (each policy maintains its own mode)
				retrievedPolicy, err := policyHelper.GetPolicy(policy.Name)
				Expect(err).NotTo(HaveOccurred(), "Should retrieve policy")
				Expect(retrievedPolicy.Spec.Mode).To(Equal(expectedMode), "Policy mode should be isolated")
			}
		})

		It("should validate policy configuration consistency", func() {
			// Test with generated configurations
			for i := 0; i < 5; i++ {
				By(fmt.Sprintf("Testing configuration consistency iteration %d", i))

				// Generate random policy configuration
				policyGen := fixtures.NewPolicyConfigGenerator()
				policyConfig := policyGen.GenerateRandomPolicyConfig(fmt.Sprintf("config-test-%d", i))

				// Create policy
				policy, err := policyHelper.CreateOptimizationPolicy(policyConfig)
				Expect(err).NotTo(HaveOccurred(), "Failed to create policy")
				cleanupHelper.TrackPolicy(policy.Name, policy.Namespace)

				// Verify configuration matches
				Expect(policy.Spec.Mode).To(Equal(policyConfig.Mode), "Mode should match")
				Expect(policy.Spec.Selector.WorkloadSelector.MatchLabels).To(Equal(policyConfig.WorkloadSelector), "Workload selector should match")
				Expect(policy.Spec.Selector.NamespaceSelector.MatchLabels).To(Equal(policyConfig.NamespaceSelector), "Namespace selector should match")

				// Verify resource bounds if set
				if policyConfig.ResourceBounds.CPU.Min != "" {
					Expect(policy.Spec.ResourceBounds).NotTo(BeNil(), "Resource bounds should be set")
					Expect(policy.Spec.ResourceBounds.CPU).NotTo(BeNil(), "CPU bounds should be set")
					Expect(policy.Spec.ResourceBounds.CPU.Min).To(Equal(policyConfig.ResourceBounds.CPU.Min), "CPU min should match")
					Expect(policy.Spec.ResourceBounds.CPU.Max).To(Equal(policyConfig.ResourceBounds.CPU.Max), "CPU max should match")
				}

				if policyConfig.ResourceBounds.Memory.Min != "" {
					Expect(policy.Spec.ResourceBounds).NotTo(BeNil(), "Resource bounds should be set")
					Expect(policy.Spec.ResourceBounds.Memory).NotTo(BeNil(), "Memory bounds should be set")
					Expect(policy.Spec.ResourceBounds.Memory.Min).To(Equal(policyConfig.ResourceBounds.Memory.Min), "Memory min should match")
					Expect(policy.Spec.ResourceBounds.Memory.Max).To(Equal(policyConfig.ResourceBounds.Memory.Max), "Memory max should match")
				}

				// Wait for policy to be processed
				err = policyHelper.WaitForPolicyReady(policy.Name, 2*time.Minute)
				Expect(err).NotTo(HaveOccurred(), "Policy should become ready")

				// Validate behavior matches configuration
				err = policyHelper.ValidatePolicyBehavior(policy.Name, policyConfig.Mode)
				Expect(err).NotTo(HaveOccurred(), "Policy behavior should match configuration")
			}
		})
	})
})

// Helper function to convert string to lowercase
func toLowerCase(s string) string {
	result := make([]rune, len(s))
	for i, r := range s {
		if r >= 'A' && r <= 'Z' {
			result[i] = r + 32
		} else {
			result[i] = r
		}
	}
	return string(result)
}
